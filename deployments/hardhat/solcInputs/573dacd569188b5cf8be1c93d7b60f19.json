{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\n\nimport \"./ERC20Permit.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when a batch price update is processed successfully.\n    /// @param chainId ID of the source chain that the batch price update comes from.\n    /// @param sequenceNumber Sequence number of the batch price update.\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "contracts/access/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ncontract Constants {\n    uint8 internal constant STAKING_PID_FOR_CHARGE_FEE = 1;\n    uint256 internal constant BASIS_POINTS_DIVISOR = 100000;\n    uint256 internal constant LIQUIDATE_THRESHOLD_DIVISOR = 10 * BASIS_POINTS_DIVISOR;\n    uint256 internal constant DEFAULT_VLP_PRICE = 100000;\n    uint256 internal constant FUNDING_RATE_PRECISION = BASIS_POINTS_DIVISOR ** 3; // 1e15\n    uint256 internal constant MAX_DEPOSIT_WITHDRAW_FEE = 10000; // 10%\n    uint256 internal constant MAX_DELTA_TIME = 24 hours;\n    uint256 internal constant MAX_COOLDOWN_DURATION = 30 days;\n    uint256 internal constant MAX_FEE_BASIS_POINTS = 5000; // 5%\n    uint256 internal constant MAX_PRICE_MOVEMENT_PERCENT = 10000; // 10%\n    uint256 internal constant MAX_BORROW_FEE_FACTOR = 500; // 0.5% per hour\n    uint256 internal constant MAX_FUNDING_RATE = FUNDING_RATE_PRECISION / 10; // 10% per hour\n    uint256 internal constant MAX_STAKING_UNSTAKING_FEE = 10000; // 10%\n    uint256 internal constant MAX_EXPIRY_DURATION = 60; // 60 seconds\n    uint256 internal constant MAX_SELF_EXECUTE_COOLDOWN = 300; // 5 minutes\n    uint256 internal constant MAX_TOKENFARM_COOLDOWN_DURATION = 4 weeks;\n    uint256 internal constant MAX_TRIGGER_GAS_FEE = 1e8 gwei;\n    uint256 internal constant MAX_MARKET_ORDER_GAS_FEE = 1e8 gwei;\n    uint256 internal constant MAX_VESTING_DURATION = 700 days;\n    uint256 internal constant MIN_LEVERAGE = 10000; // 1x\n    uint256 internal constant POSITION_MARKET = 0;\n    uint256 internal constant POSITION_LIMIT = 1;\n    uint256 internal constant POSITION_STOP_MARKET = 2;\n    uint256 internal constant POSITION_STOP_LIMIT = 3;\n    uint256 internal constant POSITION_TRAILING_STOP = 4;\n    uint256 internal constant PRICE_PRECISION = 10 ** 30;\n    uint256 internal constant TRAILING_STOP_TYPE_AMOUNT = 0;\n    uint256 internal constant TRAILING_STOP_TYPE_PERCENT = 1;\n    uint256 internal constant VLP_DECIMALS = 18;\n\n    function uintToBytes(uint v) internal pure returns (bytes32 ret) {\n        if (v == 0) {\n            ret = \"0\";\n        } else {\n            while (v > 0) {\n                ret = bytes32(uint(ret) / (2 ** 8));\n                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\n                v /= 10;\n            }\n        }\n        return ret;\n    }\n\n    function checkSlippage(bool isLong, uint256 allowedPrice, uint256 actualMarketPrice) internal pure {\n        if (isLong) {\n            require(\n                actualMarketPrice <= allowedPrice,\n                string(\n                    abi.encodePacked(\n                        \"long: slippage exceeded \",\n                        uintToBytes(actualMarketPrice),\n                        \" \",\n                        uintToBytes(allowedPrice)\n                    )\n                )\n            );\n        } else {\n            require(\n                actualMarketPrice >= allowedPrice,\n                string(\n                    abi.encodePacked(\n                        \"short: slippage exceeded \",\n                        uintToBytes(actualMarketPrice),\n                        \" \",\n                        uintToBytes(allowedPrice)\n                    )\n                )\n            );\n        }\n    }\n}\n"
    },
    "contracts/core/interfaces/ILiquidateVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Position, Order, OrderType} from \"../structs.sol\";\n\ninterface ILiquidateVault {\n    function validateLiquidationWithPosid(uint256 _posId) external view returns (bool, int256, int256, int256);\n}"
    },
    "contracts/core/interfaces/IOperators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IOperators {\n    function getOperatorLevel(address op) external view returns (uint256);\n}"
    },
    "contracts/core/interfaces/IOrderVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Order, OrderType, OrderStatus, AddPositionOrder, DecreasePositionOrder, PositionTrigger} from \"../structs.sol\";\n\ninterface IOrderVault {\n    function addTrailingStop(address _account, uint256 _posId, uint256[] memory _params) external;\n\n    function addTriggerOrders(\n        uint256 _posId,\n        address _account,\n        bool[] memory _isTPs,\n        uint256[] memory _prices,\n        uint256[] memory _amountPercents\n    ) external;\n\n    function cancelPendingOrder(address _account, uint256 _posId) external;\n\n    function updateOrder(\n        uint256 _posId,\n        uint256 _positionType,\n        uint256 _collateral,\n        uint256 _size,\n        OrderStatus _status\n    ) external;\n\n    function cancelMarketOrder(uint256 _posId) external;\n\n    function createNewOrder(\n        uint256 _posId,\n        address _accout,\n        bool _isLong,\n        uint256 _tokenId,\n        uint256 _positionType,\n        uint256[] memory _params,\n        address _refer\n    ) external;\n\n    function createAddPositionOrder(\n        address _owner,\n        uint256 _posId,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        uint256 _allowedPrice,\n        uint256 _fee\n    ) external;\n\n    function createDecreasePositionOrder(uint256 _posId, uint256 _sizeDelta, uint256 _allowedPrice) external;\n\n    function cancelAddPositionOrder(uint256 _posId) external;\n\n    function deleteAddPositionOrder(uint256 _posId) external;\n\n    function deleteDecreasePositionOrder(uint256 _posId) external;\n\n    function getOrder(uint256 _posId) external view returns (Order memory);\n\n    function getAddPositionOrder(uint256 _posId) external view returns (AddPositionOrder memory);\n\n    function getDecreasePositionOrder(uint256 _posId) external view returns (DecreasePositionOrder memory);\n\n    function getTriggerOrderInfo(uint256 _posId) external view returns (PositionTrigger memory);\n\n}"
    },
    "contracts/core/interfaces/IPositionVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {Position, Order, OrderType, PaidFees} from \"../structs.sol\";\n\ninterface IPositionVault {\n    function newPositionOrder(\n        address _account,\n        uint256 _tokenId,\n        bool _isLong,\n        OrderType _orderType,\n        uint256[] memory _params,\n        address _refer\n    ) external;\n\n    function addOrRemoveCollateral(address _account, uint256 _posId, bool isPlus, uint256 _amount) external;\n\n    function createAddPositionOrder(\n        address _account,\n        uint256 _posId,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        uint256 _allowedPrice\n    ) external;\n\n    function createDecreasePositionOrder(\n        uint256 _posId,\n        address _account,\n        uint256 _sizeDelta,\n        uint256 _allowedPrice\n    ) external;\n\n    function increasePosition(\n        uint256 _posId,\n        address _account,\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _price,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        uint256 _fee\n    ) external;\n\n    function decreasePosition(uint256 _posId, uint256 _price, uint256 _sizeDelta) external;\n\n    function decreasePositionByOrderVault(uint256 _posId, uint256 _price, uint256 _sizeDelta) external;\n\n    function removeUserAlivePosition(address _user, uint256 _posId) external;\n\n    function removeUserOpenOrder(address _user, uint256 _posId) external;\n\n    function lastPosId() external view returns (uint256);\n\n    function getPosition(uint256 _posId) external view returns (Position memory);\n\n    function getUserPositionIds(address _account) external view returns (uint256[] memory);\n\n    function getUserOpenOrderIds(address _account) external view returns (uint256[] memory);\n\n    function getPaidFees(uint256 _posId) external view returns (PaidFees memory);\n\n    function getVaultUSDBalance() external view returns (uint256);\n}"
    },
    "contracts/core/interfaces/IPriceManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IPriceManager {\n    function getLastPrice(uint256 _tokenId) external view returns (uint256);\n\n    function maxLeverage(uint256 _tokenId) external view returns (uint256);\n\n    function tokenToUsd(address _token, uint256 _tokenAmount) external view returns (uint256);\n\n    function usdToToken(address _token, uint256 _usdAmount) external view returns (uint256);\n}"
    },
    "contracts/core/interfaces/ISettingsManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ISettingsManager {\n    function decreaseOpenInterest(uint256 _tokenId, address _sender, bool _isLong, uint256 _amount) external;\n\n    function increaseOpenInterest(uint256 _tokenId, address _sender, bool _isLong, uint256 _amount) external;\n\n    function openInterestPerAssetPerSide(uint256 _tokenId, bool _isLong) external view returns (uint256);\n\n    function openInterestPerUser(address _sender) external view returns (uint256);\n\n    function bountyPercent() external view returns (uint32, uint32);\n\n    function checkBanList(address _delegate) external view returns (bool);\n\n    function checkDelegation(address _master, address _delegate) external view returns (bool);\n\n    function minCollateral() external view returns (uint256);\n\n    function closeDeltaTime() external view returns (uint256);\n\n    function expiryDuration() external view returns (uint256);\n\n    function selfExecuteCooldown() external view returns (uint256);\n\n    function cooldownDuration() external view returns (uint256);\n\n    function liquidationPendingTime() external view returns (uint256);\n\n    function depositFee(address token) external view returns (uint256);\n\n    function withdrawFee(address token) external view returns (uint256);\n\n    function feeManager() external view returns (address);\n\n    function feeRewardBasisPoints() external view returns (uint256);\n\n    function defaultBorrowFeeFactor() external view returns (uint256);\n\n    function borrowFeeFactor(uint256 tokenId) external view returns (uint256);\n\n    function totalOpenInterest() external view returns (uint256);\n\n    function basisFundingRateFactor() external view returns (uint256);\n\n    function deductFeePercent(address _account) external view returns (uint256);\n\n    function referrerTiers(address _referrer) external view returns (uint256);\n\n    function tierFees(uint256 _tier) external view returns (uint256);\n\n    function fundingIndex(uint256 _tokenId) external view returns (int256);\n\n    function fundingRateFactor(uint256 _tokenId) external view returns (uint256);\n\n    function slippageFactor(uint256 _tokenId) external view returns (uint256);\n\n    function getFundingFee(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _size,\n        int256 _fundingIndex\n    ) external view returns (int256);\n\n    function getBorrowRate(uint256 _tokenId, bool _isLong) external view returns (uint256);\n\n    function getFundingRate(uint256 _tokenId) external view returns (int256);\n\n    function getTradingFee(\n        address _account,\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _sizeDelta\n    ) external view returns (uint256);\n\n    function getPnl(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _size,\n        uint256 _averagePrice,\n        uint256 _lastPrice,\n        uint256 _lastIncreasedTime,\n        uint256 _accruedBorrowFee,\n        int256 _fundingIndex\n    ) external view returns (int256, int256, int256);\n\n    function updateFunding(uint256 _tokenId) external;\n\n    function getBorrowFee(\n        uint256 _borrowedSize,\n        uint256 _lastIncreasedTime,\n        uint256 _tokenId,\n        bool _isLong\n    ) external view returns (uint256);\n\n    function getUndiscountedTradingFee(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _sizeDelta\n    ) external view returns (uint256);\n\n    function getReferFee(address _refer) external view returns (uint256);\n\n    function getReferFeeAndTraderRebate(address _refer) external view returns (uint256 referFee, uint256 traderRebate);\n\n    function platformFees(address _platform) external view returns (uint256);\n\n    function getPriceWithSlippage(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _size,\n        uint256 _price\n    ) external view returns (uint256);\n\n    function getSlippage(uint256 _slippageFactor, uint256 _size) external view returns (uint256);\n\n    function getDelegates(address _master) external view returns (address[] memory);\n\n    function isDeposit(address _token) external view returns (bool);\n\n    function isStakingEnabled(address _token) external view returns (bool);\n\n    function isUnstakingEnabled(address _token) external view returns (bool);\n\n    function isIncreasingPositionDisabled(uint256 _tokenId) external view returns (bool);\n\n    function isDecreasingPositionDisabled(uint256 _tokenId) external view returns (bool);\n\n    function isWhitelistedFromCooldown(address _addr) external view returns (bool);\n\n    function isWhitelistedFromTransferCooldown(address _addr) external view returns (bool);\n\n    function isWithdraw(address _token) external view returns (bool);\n\n    function lastFundingTimes(uint256 _tokenId) external view returns (uint256);\n\n    function liquidateThreshold(uint256) external view returns (uint256);\n\n    function tradingFee(uint256 _tokenId, bool _isLong) external view returns (uint256);\n\n    function defaultMaxOpenInterestPerUser() external view returns (uint256);\n\n    function maxProfitPercent(uint256 _tokenId) external view returns (uint256);\n\n    function defaultMaxProfitPercent() external view returns (uint256);\n\n    function maxOpenInterestPerAssetPerSide(uint256 _tokenId, bool _isLong) external view returns (uint256);\n\n    function priceMovementPercent() external view returns (uint256);\n\n    function maxOpenInterestPerUser(address _account) external view returns (uint256);\n\n    function stakingFee(address token) external view returns (uint256);\n\n    function unstakingFee(address token) external view returns (uint256);\n\n    function triggerGasFee() external view returns (uint256);\n\n    function marketOrderGasFee() external view returns (uint256);\n\n    function maxTriggerPerPosition() external view returns (uint256);\n\n    function maxFundingRate() external view returns (uint256);\n\n    function maxTotalVlp() external view returns (uint256);\n\n    function minProfitDurations(uint256 tokenId) external view returns (uint256);\n\n    function maxCloseProfits(uint256 tokenId) external view returns (uint256);\n\n    function maxCloseProfitPercents(uint256 tokenId) external view returns (uint256);\n\n    function setMaxOpenInterestPerAsset(uint256 _tokenId, uint256 _maxAmount) external;\n\n    function lastFundingRates(uint256 tokenId) external view returns (int256);\n\n    function tempMaxFundingRateFactors(uint256 tokenId) external view returns (uint256);\n\n    function volatilityFactors(uint256 tokenId) external view returns (uint256);\n\n    function longBiasFactors(uint256 tokenId) external view returns (uint256);\n\n    function fundingRateVelocityFactors(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IVault {\n    function accountDeltaIntoTotalUSD(bool _isIncrease, uint256 _delta) external;\n\n    function distributeFee(uint256 _fee, address _refer, address _trader) external;\n\n    function takeVUSDIn(address _account, uint256 _amount) external;\n\n    function takeVUSDOut(address _account, uint256 _amount) external;\n\n    function lastStakedAt(address _account) external view returns (uint256);\n\n    function getVaultUSDBalance() external view returns (uint256);\n\n    function getVLPPrice() external view returns (uint256);\n}"
    },
    "contracts/core/LiquidateVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/IPositionVault.sol\";\nimport \"./interfaces/ILiquidateVault.sol\";\nimport \"./interfaces/IPriceManager.sol\";\nimport \"./interfaces/ISettingsManager.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IOperators.sol\";\n\nimport {Constants} from \"../access/Constants.sol\";\n\ncontract LiquidateVault is Constants, Initializable, ReentrancyGuardUpgradeable, ILiquidateVault {\n    // constants\n    ISettingsManager private settingsManager;\n    IPriceManager private priceManager;\n    IPositionVault private positionVault;\n    IOperators private operators;\n    IVault private vault;\n    bool private isInitialized;\n\n    // variables\n    mapping(uint256 => address) public liquidateRegistrant;\n    mapping(uint256 => uint256) public liquidateRegisterTime;\n\n    event RegisterLiquidation(uint256 posId, address caller);\n    event LiquidatePosition(\n        uint256 indexed posId,\n        address indexed account,\n        uint256 indexed tokenId,\n        bool isLong,\n        int256[3] pnlData,\n        uint256[5] posData\n    );\n\n    /* ========== INITIALIZE FUNCTIONS ========== */\n\n    function initialize() public initializer {\n        __ReentrancyGuard_init();\n    }\n\n    function init(\n        IPositionVault _positionVault,\n        ISettingsManager _settingsManager,\n        IVault _vault,\n        IPriceManager _priceManager,\n        IOperators _operators\n    ) external {\n        require(!isInitialized, \"initialized\");\n        require(AddressUpgradeable.isContract(address(_positionVault)), \"positionVault invalid\");\n        require(AddressUpgradeable.isContract(address(_settingsManager)), \"settingsManager invalid\");\n        require(AddressUpgradeable.isContract(address(_vault)), \"vault invalid\");\n        require(AddressUpgradeable.isContract(address(_priceManager)), \"priceManager is invalid\");\n        require(AddressUpgradeable.isContract(address(_operators)), \"operators is invalid\");\n        positionVault = _positionVault;\n        settingsManager = _settingsManager;\n        vault = _vault;\n        priceManager = _priceManager;\n        operators = _operators;\n        isInitialized = true;\n    }\n\n    /* ========== CORE FUNCTIONS ========== */\n\n    function registerLiquidatePosition(uint256 _posId) external nonReentrant {\n        (bool isPositionLiquidatable, , , ) = validateLiquidationWithPosid(_posId);\n        require(isPositionLiquidatable, \"position is not liquidatable\");\n        require(liquidateRegistrant[_posId] == address(0), \"not the firstCaller\");\n\n        liquidateRegistrant[_posId] = msg.sender;\n        liquidateRegisterTime[_posId] = block.timestamp;\n\n        emit RegisterLiquidation(_posId, msg.sender);\n    }\n\n    function liquidatePosition(uint256 _posId) external nonReentrant {\n        (bool isPositionLiquidatable, int256 pnl, int256 fundingFee, int256 borrowFee) = validateLiquidationWithPosid(\n            _posId\n        );\n        require(isPositionLiquidatable, \"position is not liquidatable\");\n        require(\n            operators.getOperatorLevel(msg.sender) >= 1 ||\n                (msg.sender == liquidateRegistrant[_posId] &&\n                    liquidateRegisterTime[_posId] + settingsManager.liquidationPendingTime() <= block.timestamp),\n            \"not manager or not allowed before pendingTime\"\n        );\n\n        Position memory position = positionVault.getPosition(_posId);\n\n        (uint32 firstCallerPercent, uint32 resolverPercent) = settingsManager.bountyPercent();\n        uint256 firstCallerBounty = (position.collateral * uint256(firstCallerPercent)) / BASIS_POINTS_DIVISOR;\n        uint256 resolverBounty = (position.collateral * uint256(resolverPercent)) / BASIS_POINTS_DIVISOR;\n        uint256 vlpBounty = position.collateral - firstCallerBounty - resolverBounty;\n\n        if (liquidateRegistrant[_posId] == address(0)) {\n            vault.takeVUSDOut(msg.sender, firstCallerBounty);\n        } else {\n            vault.takeVUSDOut(liquidateRegistrant[_posId], firstCallerBounty);\n        }\n        vault.takeVUSDOut(msg.sender, resolverBounty);\n        vault.accountDeltaIntoTotalUSD(true, vlpBounty);\n\n        settingsManager.updateFunding(position.tokenId);\n        settingsManager.decreaseOpenInterest(position.tokenId, position.owner, position.isLong, position.size);\n\n        emit LiquidatePosition(\n            _posId,\n            position.owner,\n            position.tokenId,\n            position.isLong,\n            [pnl, fundingFee, borrowFee],\n            [position.collateral, position.size, position.averagePrice, priceManager.getLastPrice(position.tokenId), 0]\n        );\n        positionVault.removeUserAlivePosition(position.owner, _posId);\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n\n    function validateLiquidationWithPosid(uint256 _posId) public view returns (bool, int256, int256, int256) {\n        Position memory position = positionVault.getPosition(_posId);\n\n        return\n            validateLiquidation(\n                position.tokenId,\n                position.isLong,\n                position.size,\n                position.averagePrice,\n                priceManager.getLastPrice(position.tokenId),\n                position.lastIncreasedTime,\n                position.accruedBorrowFee,\n                position.fundingIndex,\n                position.collateral\n            );\n    }\n\n    function validateLiquidationWithPosidAndPrice(\n        uint256 _posId,\n        uint256 _price\n    ) external view returns (bool, int256, int256, int256) {\n        Position memory position = positionVault.getPosition(_posId);\n\n        return\n            validateLiquidation(\n                position.tokenId,\n                position.isLong,\n                position.size,\n                position.averagePrice,\n                _price,\n                position.lastIncreasedTime,\n                position.accruedBorrowFee,\n                position.fundingIndex,\n                position.collateral\n            );\n    }\n\n    function validateLiquidation(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _size,\n        uint256 _averagePrice,\n        uint256 _lastPrice,\n        uint256 _lastIncreasedTime,\n        uint256 _accruedBorrowFee,\n        int256 _fundingIndex,\n        uint256 _collateral\n    ) public view returns (bool isPositionLiquidatable, int256 pnl, int256 fundingFee, int256 borrowFee) {\n        require(_size > 0, \"invalid position\");\n\n        (pnl, fundingFee, borrowFee) = settingsManager.getPnl(\n            _tokenId,\n            _isLong,\n            _size,\n            _averagePrice,\n            _lastPrice,\n            _lastIncreasedTime,\n            _accruedBorrowFee,\n            _fundingIndex\n        );\n\n        // position is liquidatable if pnl is negative and collateral larger than liquidateThreshold are lost\n        if (\n            pnl < 0 &&\n            uint256(-1 * pnl) >=\n            (_collateral * settingsManager.liquidateThreshold(_tokenId)) / LIQUIDATE_THRESHOLD_DIVISOR\n        ) {\n            isPositionLiquidatable = true;\n        }\n    }\n}"
    },
    "contracts/core/MultiCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\ncontract Multicall {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        returnData = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n            require(success);\n            returnData[i] = ret;\n        }\n    }\n\n    // Helper functions\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        blockHash = blockhash(block.number - 1);\n    }\n\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n        difficulty = block.difficulty;\n    }\n\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n}\n"
    },
    "contracts/core/Operators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\ncontract Operators is Context {\n    // level 1: normal operator\n    // level 2: rewards and feed manager\n    // level 3: admin\n    // level 4: owner\n    mapping(address => uint256) operatorLevel;\n\n    address public oldOwner;\n    address public pendingOwner;\n\n    modifier onlyOperator(uint256 level) {\n        require(operatorLevel[_msgSender()] >= level, \"invalid operator\");\n        _;\n    }\n\n    constructor() {\n        operatorLevel[_msgSender()] = 4;\n    }\n\n    function setOperator(address op, uint256 level) external onlyOperator(4) {\n        operatorLevel[op] = level;\n    }\n\n    function getOperatorLevel(address op) public view returns (uint256) {\n        return operatorLevel[op];\n    }\n\n    function transferOwnership(address newOwner) external onlyOperator(4) {\n        require(newOwner != address(0), \"zero address\");\n\n        oldOwner = _msgSender();\n        pendingOwner = newOwner;\n    }\n\n    function acceptOwnership() external {\n        require(_msgSender() == pendingOwner, \"not pendingOwner\");\n\n        operatorLevel[_msgSender()] = 4;\n        operatorLevel[oldOwner] = 0;\n\n        pendingOwner = address(0);\n        oldOwner = address(0);\n    }\n}"
    },
    "contracts/core/OrderVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"./interfaces/IOrderVault.sol\";\nimport \"./interfaces/IPositionVault.sol\";\nimport \"./interfaces/IPriceManager.sol\";\nimport \"./interfaces/ISettingsManager.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IOperators.sol\";\n\nimport {Constants} from \"../access/Constants.sol\";\nimport {OrderStatus, TriggerInfo, TriggerStatus, PositionTrigger, AddPositionOrder, DecreasePositionOrder} from \"./structs.sol\";\n\ncontract OrderVault is Constants, Initializable, ReentrancyGuardUpgradeable, IOrderVault {\n    // constants\n    IPriceManager private priceManager;\n    IPositionVault private positionVault;\n    ISettingsManager private settingsManager;\n    IVault private vault;\n    IOperators private operators;\n    bool private isInitialized;\n\n    // variables\n    mapping(uint256 => Order) public orders;\n    mapping(uint256 => AddPositionOrder) public addPositionOrders;\n    mapping(uint256 => DecreasePositionOrder) public decreasePositionOrders;\n\n    mapping(uint256 => PositionTrigger) private triggerOrders;\n    mapping(uint256 => EnumerableSetUpgradeable.UintSet) private aliveTriggerIds;\n\n    event NewOrder(\n        uint256 posId,\n        address account,\n        bool isLong,\n        uint256 tokenId,\n        uint256 positionType,\n        OrderStatus orderStatus,\n        uint256[] triggerData,\n        address refer\n    );\n    event UpdateOrder(uint256 posId, uint256 positionType, OrderStatus orderStatus);\n    event FinishOrder(uint256 posId, uint256 positionType, OrderStatus orderStatus);\n\n    event AddTriggerOrders(\n        uint256 posId,\n        uint256 orderId,\n        bool isTP,\n        uint256 price,\n        uint256 amountPercent,\n        TriggerStatus status\n    );\n    event EditTriggerOrder(uint256 indexed posId, uint256 orderId, bool isTP, uint256 price, uint256 amountPercent);\n    event ExecuteTriggerOrders(uint256 posId, uint256 amount, uint256 orderId, uint256 price);\n    event UpdateTriggerOrderStatus(uint256 posId, uint256 orderId, TriggerStatus status);\n\n    event AddTrailingStop(uint256 posId, uint256[] data);\n    event UpdateTrailingStop(uint256 posId, uint256 stpPrice);\n\n    modifier onlyVault() {\n        require(msg.sender == address(vault), \"Only vault\");\n        _;\n    }\n\n    modifier onlyPositionVault() {\n        require(msg.sender == address(positionVault), \"Only position vault\");\n        _;\n    }\n\n    modifier onlyOperator(uint256 level) {\n        require(operators.getOperatorLevel(msg.sender) >= level, \"invalid operator\");\n        _;\n    }\n\n    /* ========== INITIALIZE FUNCTIONS ========== */\n\n    function initialize() public initializer {\n        __ReentrancyGuard_init();\n    }\n\n    function init(\n        IPriceManager _priceManager,\n        IPositionVault _positionVault,\n        ISettingsManager _settingsManager,\n        IVault _vault,\n        IOperators _operators\n    ) external {\n        require(!isInitialized, \"initialized\");\n        require(AddressUpgradeable.isContract(address(_priceManager)), \"priceManager invalid\");\n        require(AddressUpgradeable.isContract(address(_positionVault)), \"positionVault invalid\");\n        require(AddressUpgradeable.isContract(address(_settingsManager)), \"settingsManager invalid\");\n        require(AddressUpgradeable.isContract(address(_vault)), \"vault invalid\");\n        require(AddressUpgradeable.isContract(address(_operators)), \"operators is invalid\");\n\n        priceManager = _priceManager;\n        settingsManager = _settingsManager;\n        positionVault = _positionVault;\n        vault = _vault;\n        operators = _operators;\n\n        isInitialized = true;\n    }\n\n    /* ========== FOR OPENING POSITIONS ========== */\n\n    function createNewOrder(\n        uint256 _posId,\n        address _account,\n        bool _isLong,\n        uint256 _tokenId,\n        uint256 _positionType,\n        uint256[] memory _params,\n        address _refer\n    ) external override onlyPositionVault {\n        Order storage order = orders[_posId];\n        order.status = OrderStatus.PENDING;\n        order.positionType = _positionType;\n        order.collateral = _params[2];\n        order.size = _params[3];\n        order.lmtPrice = _params[0];\n        order.stpPrice = _params[1];\n        order.timestamp = block.timestamp;\n        emit NewOrder(_posId, _account, _isLong, _tokenId, order.positionType, order.status, _params, _refer);\n    }\n\n    function cancelMarketOrder(uint256 _posId) public override onlyPositionVault {\n        // only cancel if the order still exists\n        if (orders[_posId].size > 0) {\n            Order storage order = orders[_posId];\n            order.status = OrderStatus.CANCELED;\n\n            Position memory position = positionVault.getPosition(_posId);\n            vault.takeVUSDOut(position.owner, order.collateral + positionVault.getPaidFees(_posId).paidPositionFee);\n\n            emit FinishOrder(_posId, order.positionType, order.status);\n        }\n    }\n\n    function cancelPendingOrder(address _account, uint256 _posId) external override onlyVault {\n        Order storage order = orders[_posId];\n        Position memory position = positionVault.getPosition(_posId);\n        require(_account == position.owner, \"You are not allowed to cancel\");\n        require(order.status == OrderStatus.PENDING, \"Not in Pending\");\n        require(order.positionType != POSITION_MARKET, \"market order cannot be cancelled\");\n        if (order.positionType == POSITION_TRAILING_STOP) {\n            order.status = OrderStatus.FILLED;\n            order.positionType = POSITION_MARKET;\n        } else {\n            order.status = OrderStatus.CANCELED;\n            vault.takeVUSDOut(position.owner, order.collateral + positionVault.getPaidFees(_posId).paidPositionFee);\n        }\n        order.collateral = 0;\n        order.size = 0;\n        order.lmtPrice = 0;\n        order.stpPrice = 0;\n        emit FinishOrder(_posId, order.positionType, order.status);\n    }\n\n    function updateOrder(\n        uint256 _posId,\n        uint256 _positionType,\n        uint256 _collateral,\n        uint256 _size,\n        OrderStatus _status\n    ) public override onlyPositionVault {\n        _updateOrder(_posId, _positionType, _collateral, _size, _status);\n    }\n\n    function _updateOrder(\n        uint256 _posId,\n        uint256 _positionType,\n        uint256 _collateral,\n        uint256 _size,\n        OrderStatus _status\n    ) private {\n        Order storage order = orders[_posId];\n        order.positionType = _positionType;\n        order.collateral = _collateral;\n        order.size = _size;\n        order.status = _status;\n        if (_status == OrderStatus.FILLED || _status == OrderStatus.CANCELED) {\n            emit FinishOrder(_posId, _positionType, _status);\n        } else {\n            emit UpdateOrder(_posId, _positionType, _status);\n        }\n    }\n\n    /* ========== FOR ADDING POSITIONS ========== */\n\n    function createAddPositionOrder(\n        address _owner,\n        uint256 _posId,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        uint256 _allowedPrice,\n        uint256 _fee\n    ) external override onlyPositionVault {\n        require(addPositionOrders[_posId].size == 0, \"addPositionOrder already exists\");\n\n        addPositionOrders[_posId] = AddPositionOrder({\n            owner: _owner,\n            collateral: _collateralDelta,\n            size: _sizeDelta,\n            allowedPrice: _allowedPrice,\n            timestamp: block.timestamp,\n            fee: _fee\n        });\n    }\n\n    function cancelAddPositionOrder(uint256 _posId) external override onlyPositionVault {\n        AddPositionOrder memory addPositionOrder = addPositionOrders[_posId];\n\n        if (addPositionOrder.size > 0) {\n            vault.takeVUSDOut(addPositionOrder.owner, addPositionOrder.collateral + addPositionOrder.fee);\n            delete addPositionOrders[_posId];\n        }\n    }\n\n    function deleteAddPositionOrder(uint256 _posId) external override onlyPositionVault {\n        delete addPositionOrders[_posId];\n    }\n\n    /* ========== FOR CLOSING POSITIONS (MARKET ORDER) ========== */\n\n    function createDecreasePositionOrder(\n        uint256 _posId,\n        uint256 _sizeDelta,\n        uint256 _allowedPrice\n    ) external override onlyPositionVault {\n        require(decreasePositionOrders[_posId].size == 0, \"decreasePositionOrder already exists\");\n\n        decreasePositionOrders[_posId] = DecreasePositionOrder({\n            size: _sizeDelta,\n            allowedPrice: _allowedPrice,\n            timestamp: block.timestamp\n        });\n    }\n\n    function deleteDecreasePositionOrder(uint256 _posId) external override onlyPositionVault {\n        delete decreasePositionOrders[_posId];\n    }\n\n    /* ========== FOR CLOSING POSITIONS (TPSL ORDER) ========== */\n\n    function addTriggerOrders(\n        uint256 _posId,\n        address _account,\n        bool[] memory _isTPs,\n        uint256[] memory _prices,\n        uint256[] memory _amountPercents\n    ) external override onlyVault {\n        Position memory position = positionVault.getPosition(_posId);\n        require(position.owner == _account, \"not allowed\");\n        require(_prices.length == _isTPs.length && _prices.length == _amountPercents.length, \"invalid params\");\n        require(_prices.length > 0, \"empty order\");\n        require(\n            EnumerableSetUpgradeable.length(aliveTriggerIds[_posId]) + _prices.length <=\n                settingsManager.maxTriggerPerPosition(),\n            \"too many triggers\"\n        );\n        PositionTrigger storage triggerOrder = triggerOrders[_posId];\n\n        for (uint256 i; i < _prices.length; ++i) {\n            require(_amountPercents[i] > 0 && _amountPercents[i] <= BASIS_POINTS_DIVISOR, \"invalid percent\");\n\n            uint256 triggersLength = triggerOrder.triggers.length;\n            EnumerableSetUpgradeable.add(aliveTriggerIds[_posId], triggersLength);\n            triggerOrder.triggers.push(\n                TriggerInfo({\n                    isTP: _isTPs[i],\n                    amountPercent: _amountPercents[i],\n                    createdAt: block.timestamp,\n                    price: _prices[i],\n                    triggeredAmount: 0,\n                    triggeredAt: 0,\n                    status: TriggerStatus.OPEN\n                })\n            );\n            emit AddTriggerOrders(\n                _posId,\n                triggersLength,\n                _isTPs[i],\n                _prices[i],\n                _amountPercents[i],\n                TriggerStatus.OPEN\n            );\n        }\n    }\n\n    function cancelTriggerOrder(uint256 _posId, uint256 _orderId) external nonReentrant {\n        _cancelTriggerOrder(_posId, _orderId);\n    }\n\n    function cancelTriggerOrderPacked(uint256 x) external nonReentrant {\n        uint256 posId = x / 2 ** 128;\n        uint256 orderId = x % 2 ** 128;\n        _cancelTriggerOrder(posId, orderId);\n    }\n\n    function _cancelTriggerOrder(uint256 _posId, uint256 _orderId) private {\n        PositionTrigger storage order = triggerOrders[_posId];\n        Position memory position = positionVault.getPosition(_posId);\n        require(position.owner == msg.sender, \"not allowed\");\n        require(order.triggers[_orderId].status == TriggerStatus.OPEN, \"TriggerOrder was cancelled\");\n        order.triggers[_orderId].status = TriggerStatus.CANCELLED;\n        EnumerableSetUpgradeable.remove(aliveTriggerIds[_posId], _orderId);\n        emit UpdateTriggerOrderStatus(_posId, _orderId, order.triggers[_orderId].status);\n    }\n\n    function cancelAllTriggerOrders(uint256 _posId) external nonReentrant {\n        PositionTrigger storage order = triggerOrders[_posId];\n        Position memory position = positionVault.getPosition(_posId);\n        require(position.owner == msg.sender, \"not allowed\");\n        uint256 length = EnumerableSetUpgradeable.length(aliveTriggerIds[_posId]);\n        require(length > 0, \"already cancelled\");\n        uint256[] memory tmp = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            uint256 idx = EnumerableSetUpgradeable.at(aliveTriggerIds[_posId], i);\n            TriggerInfo storage trigger = order.triggers[idx];\n            trigger.status = TriggerStatus.CANCELLED;\n            emit UpdateTriggerOrderStatus(_posId, idx, trigger.status);\n            tmp[i] = idx;\n        }\n        for (uint256 i = 0; i < length; ++i) {\n            EnumerableSetUpgradeable.remove(aliveTriggerIds[_posId], tmp[i]);\n        }\n    }\n\n    function editTriggerOrder(\n        uint256 _posId,\n        uint256 _orderId,\n        bool _isTP,\n        uint256 _price,\n        uint256 _amountPercent\n    ) external nonReentrant {\n        PositionTrigger storage order = triggerOrders[_posId];\n        Position memory position = positionVault.getPosition(_posId);\n        require(position.owner == msg.sender, \"not allowed\");\n        require(order.triggers[_orderId].status == TriggerStatus.OPEN, \"TriggerOrder not Open\");\n        require(_amountPercent > 0 && _amountPercent <= BASIS_POINTS_DIVISOR, \"invalid percent\");\n\n        order.triggers[_orderId].isTP = _isTP;\n        order.triggers[_orderId].price = _price;\n        order.triggers[_orderId].amountPercent = _amountPercent;\n        order.triggers[_orderId].createdAt = block.timestamp;\n\n        emit EditTriggerOrder(_posId, _orderId, _isTP, _price, _amountPercent);\n    }\n\n    function executeTriggerOrders(uint256 _posId) internal returns (uint256, uint256) {\n        PositionTrigger storage order = triggerOrders[_posId];\n        Position memory position = positionVault.getPosition(_posId);\n        require(position.size > 0, \"Trigger Not Open\");\n        uint256 price = priceManager.getLastPrice(position.tokenId);\n        for (uint256 i = 0; i < EnumerableSetUpgradeable.length(aliveTriggerIds[_posId]); ++i) {\n            uint256 idx = EnumerableSetUpgradeable.at(aliveTriggerIds[_posId], i);\n            TriggerInfo storage trigger = order.triggers[idx];\n            if (validateTrigger(trigger.status, trigger.isTP, position.isLong, trigger.price, price)) {\n                uint256 triggerAmount = (position.size * trigger.amountPercent) / BASIS_POINTS_DIVISOR;\n                trigger.triggeredAmount = triggerAmount;\n                trigger.triggeredAt = block.timestamp;\n                trigger.status = TriggerStatus.TRIGGERED;\n                EnumerableSetUpgradeable.remove(aliveTriggerIds[_posId], idx);\n                emit ExecuteTriggerOrders(_posId, trigger.triggeredAmount, idx, price);\n                return (triggerAmount, price);\n            }\n        }\n        revert(\"trigger not ready\");\n    }\n\n    function validateTrigger(\n        TriggerStatus _status,\n        bool _isTP,\n        bool _isLong,\n        uint256 _triggerPrice,\n        uint256 _lastPrice\n    ) private pure returns (bool) {\n        if (_status != TriggerStatus.OPEN) return false;\n\n        if (_isTP) {\n            if (_isLong) {\n                if (_lastPrice >= _triggerPrice) return true;\n            } else {\n                if (_lastPrice <= _triggerPrice) return true;\n            }\n        } else {\n            if (_isLong) {\n                if (_lastPrice <= _triggerPrice) return true;\n            } else {\n                if (_lastPrice >= _triggerPrice) return true;\n            }\n        }\n\n        return false;\n    }\n\n    /* ========== FOR CLOSING POSITIONS (TRAILING STOP ORDER) ========== */\n\n    function addTrailingStop(address _account, uint256 _posId, uint256[] memory _params) external override onlyVault {\n        Order storage order = orders[_posId];\n        Position memory position = positionVault.getPosition(_posId);\n        require(_account == position.owner, \"you are not allowed to add trailing stop\");\n        require(position.size > 0, \"position not alive\");\n        validateTrailingStopInputData(_params);\n        if (position.size < _params[1]) {\n            order.size = position.size;\n        } else {\n            order.size = _params[1];\n        }\n        order.collateral = _params[0];\n        order.status = OrderStatus.PENDING;\n        order.positionType = POSITION_TRAILING_STOP;\n        order.stepType = _params[2];\n        order.stpPrice = _params[3];\n        order.stepAmount = _params[4];\n        emit AddTrailingStop(_posId, _params);\n    }\n\n    function validateTrailingStopInputData(uint256[] memory _params) public pure returns (bool) {\n        require(_params[1] > 0, \"trailing size is zero\");\n        require(_params[4] > 0 && _params[3] > 0, \"invalid trailing data\");\n        require(_params[2] <= 1, \"invalid type\");\n        if (_params[2] == TRAILING_STOP_TYPE_PERCENT) {\n            require(_params[4] < BASIS_POINTS_DIVISOR, \"percent cant exceed 100%\");\n        }\n        return true;\n    }\n\n    function updateTrailingStop(uint256 _posId) external nonReentrant {\n        Position memory position = positionVault.getPosition(_posId);\n        Order storage order = orders[_posId];\n        uint256 price = priceManager.getLastPrice(position.tokenId);\n        require(position.owner == msg.sender || operators.getOperatorLevel(msg.sender) >= 1, \"updateTStop not allowed\");\n        require(position.size > 0, \"position not alive\");\n        validateTrailingStopPrice(position.tokenId, position.isLong, _posId, true);\n        uint256 oldStpPrice = order.stpPrice;\n        if (position.isLong) {\n            order.stpPrice = order.stepType == 0\n                ? price - order.stepAmount\n                : (price * (BASIS_POINTS_DIVISOR - order.stepAmount)) / BASIS_POINTS_DIVISOR;\n        } else {\n            order.stpPrice = order.stepType == 0\n                ? price + order.stepAmount\n                : (price * (BASIS_POINTS_DIVISOR + order.stepAmount)) / BASIS_POINTS_DIVISOR;\n        }\n        uint256 diff;\n        if (order.stpPrice > oldStpPrice) {\n            diff = order.stpPrice - oldStpPrice;\n        } else {\n            diff = oldStpPrice - order.stpPrice;\n        }\n        require(\n            (diff * BASIS_POINTS_DIVISOR) / oldStpPrice >= settingsManager.priceMovementPercent(),\n            \"!price movement\"\n        );\n        emit UpdateTrailingStop(_posId, order.stpPrice);\n    }\n\n    function validateTrailingStopPrice(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _posId,\n        bool _raise\n    ) public view returns (bool) {\n        Order memory order = orders[_posId];\n        uint256 price = priceManager.getLastPrice(_tokenId);\n        uint256 stopPrice;\n        if (_isLong) {\n            if (order.stepType == TRAILING_STOP_TYPE_AMOUNT) {\n                stopPrice = order.stpPrice + order.stepAmount;\n            } else {\n                stopPrice = (order.stpPrice * BASIS_POINTS_DIVISOR) / (BASIS_POINTS_DIVISOR - order.stepAmount);\n            }\n        } else {\n            if (order.stepType == TRAILING_STOP_TYPE_AMOUNT) {\n                stopPrice = order.stpPrice - order.stepAmount;\n            } else {\n                stopPrice = (order.stpPrice * BASIS_POINTS_DIVISOR) / (BASIS_POINTS_DIVISOR + order.stepAmount);\n            }\n        }\n        bool flag;\n        if (\n            _isLong &&\n            order.status == OrderStatus.PENDING &&\n            order.positionType == POSITION_TRAILING_STOP &&\n            stopPrice <= price\n        ) {\n            flag = true;\n        } else if (\n            !_isLong &&\n            order.status == OrderStatus.PENDING &&\n            order.positionType == POSITION_TRAILING_STOP &&\n            stopPrice >= price\n        ) {\n            flag = true;\n        }\n        if (_raise) {\n            require(flag, \"price incorrect\");\n        }\n        return flag;\n    }\n\n    /* ========== EXECUTE ORDERS ========== */\n\n    function triggerForOpenOrders(uint256 _posId) external nonReentrant onlyOperator(1) {\n        Position memory position = positionVault.getPosition(_posId);\n        Order memory order = orders[_posId];\n        require(order.status == OrderStatus.PENDING, \"order not pending\");\n        uint256 price = priceManager.getLastPrice(position.tokenId);\n\n        if (order.positionType == POSITION_LIMIT) {\n            if (position.isLong) {\n                require(order.lmtPrice >= price, \"trigger not met\");\n            } else {\n                require(order.lmtPrice <= price, \"trigger not met\");\n            }\n            positionVault.increasePosition(\n                _posId,\n                position.owner,\n                position.tokenId,\n                position.isLong,\n                price,\n                order.collateral,\n                order.size,\n                positionVault.getPaidFees(_posId).paidPositionFee\n            );\n            _updateOrder(_posId, order.positionType, 0, 0, OrderStatus.FILLED);\n            positionVault.removeUserOpenOrder(position.owner, _posId);\n        } else if (order.positionType == POSITION_STOP_MARKET) {\n            if (position.isLong) {\n                require(order.stpPrice <= price, \"trigger not met\");\n            } else {\n                require(order.stpPrice >= price, \"trigger not met\");\n            }\n            positionVault.increasePosition(\n                _posId,\n                position.owner,\n                position.tokenId,\n                position.isLong,\n                price,\n                order.collateral,\n                order.size,\n                positionVault.getPaidFees(_posId).paidPositionFee\n            );\n            _updateOrder(_posId, order.positionType, 0, 0, OrderStatus.FILLED);\n            positionVault.removeUserOpenOrder(position.owner, _posId);\n        } else if (order.positionType == POSITION_STOP_LIMIT) {\n            if (position.isLong) {\n                require(order.stpPrice <= price, \"trigger not met\");\n            } else {\n                require(order.stpPrice >= price, \"trigger not met\");\n            }\n            _updateOrder(_posId, POSITION_LIMIT, order.collateral, order.size, order.status);\n        } else if (order.positionType == POSITION_TRAILING_STOP) {\n            if (position.isLong) {\n                require(order.stpPrice >= price, \"trigger not met\");\n            } else {\n                require(order.stpPrice <= price, \"trigger not met\");\n            }\n            positionVault.decreasePositionByOrderVault(_posId, price, order.size);\n            _updateOrder(_posId, POSITION_MARKET, 0, 0, OrderStatus.FILLED);\n        } else {\n            revert(\"!positionType\");\n        }\n    }\n\n    function triggerForTPSL(uint256 _posId) external nonReentrant onlyOperator(1) {\n        (uint256 triggeredAmount, uint256 triggerPrice) = executeTriggerOrders(_posId);\n        positionVault.decreasePositionByOrderVault(_posId, triggerPrice, triggeredAmount);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function getOrder(uint256 _posId) external view override returns (Order memory) {\n        return orders[_posId];\n    }\n\n    function getAddPositionOrder(uint256 _posId) external view override returns (AddPositionOrder memory) {\n        return addPositionOrders[_posId];\n    }\n\n    function getDecreasePositionOrder(uint256 _posId) external view override returns (DecreasePositionOrder memory) {\n        return decreasePositionOrders[_posId];\n    }\n\n    function getTriggerOrderInfo(uint256 _posId) external view override returns (PositionTrigger memory) {\n        return triggerOrders[_posId];\n    }\n\n    function getAliveTriggerIds(uint256 _posId) external view returns (uint256[] memory _aliveTriggerIds) {\n        uint256 length = EnumerableSetUpgradeable.length(aliveTriggerIds[_posId]);\n        _aliveTriggerIds = new uint256[](length);\n\n        for (uint256 i; i < length; ++i) {\n            _aliveTriggerIds[i] = EnumerableSetUpgradeable.at(aliveTriggerIds[_posId], i);\n        }\n    }\n}"
    },
    "contracts/core/PositionVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./interfaces/ILiquidateVault.sol\";\nimport \"./interfaces/IPositionVault.sol\";\nimport \"./interfaces/IPriceManager.sol\";\nimport \"./interfaces/ISettingsManager.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IOrderVault.sol\";\nimport \"./interfaces/IOperators.sol\";\n\nimport {Constants} from \"../access/Constants.sol\";\nimport {OrderStatus, PaidFees, Temp} from \"./structs.sol\";\n\ncontract PositionVault is Constants, Initializable, ReentrancyGuardUpgradeable, IPositionVault {\n    // constants\n    ISettingsManager private settingsManager;\n    ILiquidateVault private liquidateVault;\n    IPriceManager private priceManager;\n    IOrderVault private orderVault;\n    IOperators private operators;\n    IVault private vault;\n    bool private isInitialized;\n\n    // variables\n    uint256 public override lastPosId;\n    mapping(uint256 => Position) private positions; // posId => Position{}\n    mapping(address => uint256[]) private userPositionIds; // userAddress => alive posIds[]\n    mapping(address => uint256[]) private userOpenOrderIds; // userAddress => open orderIds[]\n    mapping(uint256 => uint256) private userAliveIndexOf; // posId => index of userPositionIds[user], note that a position can only have a user\n    mapping(uint256 => uint256) private userOpenOrderIndexOf; // posId => index of userPositionIds[user], note that a position can only have a user\n    mapping(uint256 => PaidFees) private paidFees; // to track paid fees for each position\n\n    // variables to faciliate market order execution (easier to batch execute and track without using event)\n    uint256 public queueIndex;\n    uint256[] public queuePosIds;\n\n    mapping(uint256 => uint256) public removeCollateralOrders; // posId => collateralAmount\n\n    event AddOrRemoveCollateral(uint256 posId, bool isPlus, uint256 amount, uint256 collateral, uint256 size);\n    event ExecuteRemoveCollateral(uint256 posId);\n    event ExecuteRemoveCollateralError(uint256 indexed posId, address indexed account, string err);\n    event CreateAddPositionOrder(uint256 posId, uint256 collateral, uint256 size, uint256 allowedPrice);\n    event CreateDecreasePositionOrder(uint256 posId, uint256 size, uint256 allowedPrice);\n    event ExecuteAddPositionOrder(uint256 posId, uint256 collateral, uint256 size, uint256 feeUsd);\n    event ExecuteDecreasePositionOrder(uint256 posId, uint256 size);\n    event MarketOrderExecutionError(uint256 indexed posId, address indexed account, string err);\n    event AddPositionExecutionError(uint256 indexed posId, address indexed account, string err);\n    event DecreasePositionExecutionError(uint256 indexed posId, address indexed account, string err);\n    event IncreasePosition(\n        uint256 indexed posId,\n        address indexed account,\n        uint256 indexed tokenId,\n        bool isLong,\n        uint256[5] posData\n    );\n    event DecreasePosition(\n        uint256 indexed posId,\n        address indexed account,\n        uint256 indexed tokenId,\n        bool isLong,\n        int256[3] pnlData,\n        uint256[5] posData\n    );\n    event ClosePosition(\n        uint256 indexed posId,\n        address indexed account,\n        uint256 indexed tokenId,\n        bool isLong,\n        int256[3] pnlData,\n        uint256[5] posData\n    );\n\n    modifier onlyVault() {\n        _onlyVault();\n        _;\n    }\n\n    function _onlyVault() private view {\n        require(msg.sender == address(vault), \"Only vault\");\n    }\n\n    modifier onlyOrderVault() {\n        _onlyOrderVault();\n        _;\n    }\n\n    function _onlyOrderVault() private view {\n        require(msg.sender == address(orderVault), \"Only vault\");\n    }\n\n    modifier onlyLiquidateVault() {\n        require(msg.sender == address(liquidateVault), \"Only vault\");\n        _;\n    }\n\n    modifier onlyOperator(uint256 level) {\n        _onlyOperator(level);\n        _;\n    }\n\n    function _onlyOperator(uint256 level) private view {\n        require(operators.getOperatorLevel(msg.sender) >= level, \"invalid operator\");\n    }\n\n    /* ========== INITIALIZE FUNCTIONS ========== */\n\n    function initialize(address _vault, address _priceManager, address _operators) public initializer {\n        __ReentrancyGuard_init();\n        // intitialize the admins\n        vault = IVault(_vault);\n        priceManager = IPriceManager(_priceManager);\n        operators = IOperators(_operators);\n    }\n\n    function init(\n        IOrderVault _orderVault,\n        ILiquidateVault _liquidateVault,\n        ISettingsManager _settingsManager\n    ) external {\n        require(!isInitialized, \"initialized\");\n\n        liquidateVault = _liquidateVault;\n        orderVault = _orderVault;\n        settingsManager = _settingsManager;\n\n        isInitialized = true;\n    }\n\n    /* ========== USER FUNCTIONS ========== */\n\n    function newPositionOrder(\n        address _account,\n        uint256 _tokenId,\n        bool _isLong,\n        OrderType _orderType,\n        // 0 -> market order\n        // 1 -> limit order\n        // 2 -> stop-market order\n        // 3 -> stop-limit order\n        uint256[] memory _params,\n        // for market order:  _params[0] -> allowed price (revert if exceeded)\n        // for limit order: _params[0] -> limit price\n        // In stop-market order: _params[1] -> stop price,\n        // In stop-limit order: _params[0] -> limit price, _params[1] -> stop price\n        // for all orders: _params[2] -> collateral\n        // for all orders: _params[3] -> size\n        address _refer\n    ) external onlyVault {\n        validateIncreasePosition(_tokenId, _params[2], _params[3]);\n\n        uint256 _lastPosId = lastPosId;\n        Position storage position = positions[_lastPosId];\n        position.owner = _account;\n        position.refer = _refer;\n        position.tokenId = _tokenId;\n        position.isLong = _isLong;\n\n        uint256 fee = settingsManager.getTradingFee(_account, _tokenId, _isLong, _params[3]);\n        paidFees[_lastPosId].paidPositionFee = fee;\n        vault.takeVUSDIn(_account, _params[2] + fee);\n\n        if (_orderType == OrderType.MARKET) {\n            require(\n                !settingsManager.isIncreasingPositionDisabled(_tokenId),\n                \"current asset is disabled from increasing position\"\n            );\n            require(_params[0] > 0, \"market price is invalid\");\n            orderVault.createNewOrder(_lastPosId, _account, _isLong, _tokenId, POSITION_MARKET, _params, _refer);\n            queuePosIds.push(_lastPosId);\n        } else if (_orderType == OrderType.LIMIT) {\n            require(_params[0] > 0, \"limit price is invalid\");\n            orderVault.createNewOrder(_lastPosId, _account, _isLong, _tokenId, POSITION_LIMIT, _params, _refer);\n            _addUserOpenOrder(position.owner, _lastPosId);\n        } else if (_orderType == OrderType.STOP) {\n            require(_params[1] > 0, \"stop price is invalid\");\n            orderVault.createNewOrder(_lastPosId, _account, _isLong, _tokenId, POSITION_STOP_MARKET, _params, _refer);\n            _addUserOpenOrder(position.owner, _lastPosId);\n        } else if (_orderType == OrderType.STOP_LIMIT) {\n            require(_params[0] > 0 && _params[1] > 0, \"stop limit price is invalid\");\n            orderVault.createNewOrder(_lastPosId, _account, _isLong, _tokenId, POSITION_STOP_LIMIT, _params, _refer);\n            _addUserOpenOrder(position.owner, _lastPosId);\n        } else {\n            revert(\"invalid order type\");\n        }\n\n        lastPosId = _lastPosId + 1;\n    }\n\n    function addOrRemoveCollateral(\n        address _account,\n        uint256 _posId,\n        bool isPlus,\n        uint256 _amount\n    ) external override onlyVault {\n        Position storage position = positions[_posId];\n        require(_account == position.owner, \"you are not allowed to add position\");\n        require(position.size > 0, \"Position not Open\");\n\n        if (isPlus) {\n            position.collateral += _amount;\n            validateMinLeverage(position.size, position.collateral);\n            vault.takeVUSDIn(_account, _amount);\n            emit AddOrRemoveCollateral(_posId, isPlus, _amount, position.collateral, position.size);\n        } else {\n            require(removeCollateralOrders[_posId] == 0, \"order already exists\");\n            removeCollateralOrders[_posId] = _amount;\n\n            queuePosIds.push(3 * 2 ** 128 + _posId);\n        }\n    }\n\n    function createAddPositionOrder(\n        address _account,\n        uint256 _posId,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        uint256 _allowedPrice\n    ) external override onlyVault {\n        Position memory position = positions[_posId];\n\n        require(\n            !settingsManager.isIncreasingPositionDisabled(position.tokenId),\n            \"current asset is disabled from increasing position\"\n        );\n        require(position.size > 0, \"Position not Open\");\n        require(_account == position.owner, \"you are not allowed to add position\");\n        validateIncreasePosition(position.tokenId, _collateralDelta, _sizeDelta);\n\n        uint256 fee = settingsManager.getTradingFee(_account, position.tokenId, position.isLong, _sizeDelta);\n        vault.takeVUSDIn(_account, _collateralDelta + fee);\n        orderVault.createAddPositionOrder(_account, _posId, _collateralDelta, _sizeDelta, _allowedPrice, fee);\n\n        queuePosIds.push(2 ** 128 + _posId);\n\n        emit CreateAddPositionOrder(_posId, _collateralDelta, _sizeDelta, _allowedPrice);\n    }\n\n    function createDecreasePositionOrder(\n        uint256 _posId,\n        address _account,\n        uint256 _sizeDelta,\n        uint256 _allowedPrice\n    ) external override onlyVault {\n        Position memory position = positions[_posId];\n\n        require(_sizeDelta > 0, \"invalid size\");\n        require(position.size > 0, \"Position not Open\");\n        require(_account == position.owner, \"not allowed\");\n\n        orderVault.createDecreasePositionOrder(_posId, _sizeDelta, _allowedPrice);\n\n        queuePosIds.push(2 ** 129 + _posId);\n\n        emit CreateDecreasePositionOrder(_posId, _sizeDelta, _allowedPrice);\n    }\n\n    // allow users to close their positions themselves after selfExecuteCooldown, in case keepers are down\n    function selfExecuteDecreasePositionOrder(uint256 _posId) external nonReentrant {\n        Position memory position = positions[_posId];\n        require(msg.sender == position.owner, \"!owner\");\n\n        DecreasePositionOrder memory decreasePositionOrder = orderVault.getDecreasePositionOrder(_posId);\n        require(\n            block.timestamp > decreasePositionOrder.timestamp + settingsManager.selfExecuteCooldown(),\n            \"cannot self execute yet\"\n        );\n\n        uint256 price = priceManager.getLastPrice(position.tokenId);\n        // without check slippage to ensure success execute\n        // user should read contract price feed to know the price before execution\n        _decreasePosition(_posId, price, decreasePositionOrder.size);\n        orderVault.deleteDecreasePositionOrder(_posId);\n    }\n\n    /* ========== OPERATOR FUNCTIONS ========== */\n\n    function executeRemoveCollateral(uint256 _posId) external nonReentrant onlyOperator(1) {\n        uint256 removeCollateralAmount = removeCollateralOrders[_posId];\n        require(removeCollateralAmount > 0, \"empty order\");\n        Position storage position = positions[_posId];\n        require(position.size > 0, \"Position not Open\");\n\n        position.collateral -= removeCollateralAmount;\n        validateMaxLeverage(position.tokenId, position.size, position.collateral);\n        (bool isPositionLiquidatable, , , ) = liquidateVault.validateLiquidationWithPosid(_posId);\n        require(!isPositionLiquidatable, \"position will be liquidated\");\n        vault.takeVUSDOut(position.owner, removeCollateralAmount);\n\n        delete removeCollateralOrders[_posId];\n\n        emit AddOrRemoveCollateral(_posId, false, removeCollateralAmount, position.collateral, position.size);\n    }\n\n    function executeOpenMarketOrder(uint256 _posId) public nonReentrant onlyOperator(1) {\n        Position memory position = positions[_posId];\n        Order memory order = orderVault.getOrder(_posId);\n\n        require(order.size > 0 && order.status == OrderStatus.PENDING, \"not open\");\n        require(order.positionType == POSITION_MARKET, \"not market order\");\n        require(block.timestamp <= order.timestamp + settingsManager.expiryDuration(), \"order has expired\");\n\n        uint256 price = priceManager.getLastPrice(position.tokenId);\n        uint256 priceWithSlippage = settingsManager.getPriceWithSlippage(\n            position.tokenId,\n            position.isLong,\n            order.size,\n            price\n        );\n        checkSlippage(position.isLong, order.lmtPrice, priceWithSlippage);\n\n        _increasePosition(\n            _posId,\n            position.owner,\n            position.tokenId,\n            position.isLong,\n            price,\n            order.collateral,\n            order.size,\n            paidFees[_posId].paidPositionFee\n        );\n        orderVault.updateOrder(_posId, order.positionType, 0, 0, OrderStatus.FILLED);\n    }\n\n    function executeAddPositionOrder(uint256 _posId) external nonReentrant onlyOperator(1) {\n        Position memory position = positions[_posId];\n        AddPositionOrder memory addPositionOrder = orderVault.getAddPositionOrder(_posId);\n\n        require(addPositionOrder.size > 0, \"order size is 0\");\n        require(block.timestamp <= addPositionOrder.timestamp + settingsManager.expiryDuration(), \"order has expired\");\n\n        uint256 price = priceManager.getLastPrice(position.tokenId);\n        uint256 priceWithSlippage = settingsManager.getPriceWithSlippage(\n            position.tokenId,\n            position.isLong,\n            addPositionOrder.size,\n            price\n        );\n        checkSlippage(position.isLong, addPositionOrder.allowedPrice, priceWithSlippage);\n\n        _increasePosition(\n            _posId,\n            position.owner,\n            position.tokenId,\n            position.isLong,\n            price,\n            addPositionOrder.collateral,\n            addPositionOrder.size,\n            addPositionOrder.fee\n        );\n        orderVault.deleteAddPositionOrder(_posId);\n\n        emit ExecuteAddPositionOrder(_posId, addPositionOrder.collateral, addPositionOrder.size, addPositionOrder.fee);\n    }\n\n    function executeDecreasePositionOrder(uint256 _posId) external nonReentrant onlyOperator(1) {\n        Position memory position = positions[_posId];\n        DecreasePositionOrder memory decreasePositionOrder = orderVault.getDecreasePositionOrder(_posId);\n\n        require(\n            block.timestamp <= decreasePositionOrder.timestamp + settingsManager.expiryDuration(),\n            \"order has expired\"\n        );\n\n        uint256 decreaseSize = decreasePositionOrder.size > position.size ? position.size : decreasePositionOrder.size;\n        uint256 price = priceManager.getLastPrice(position.tokenId);\n        uint256 priceWithSlippage = settingsManager.getPriceWithSlippage(\n            position.tokenId,\n            !position.isLong, // decreasePosition is in opposite direction\n            decreaseSize,\n            price\n        );\n        checkSlippage(!position.isLong, decreasePositionOrder.allowedPrice, priceWithSlippage);\n\n        _decreasePosition(_posId, price, decreaseSize);\n        orderVault.deleteDecreasePositionOrder(_posId);\n\n        emit ExecuteDecreasePositionOrder(_posId, decreaseSize);\n    }\n\n    function executeOrders(uint256 numOfOrders) external onlyOperator(1) {\n        uint256 index = queueIndex;\n        uint256 endIndex = index + numOfOrders;\n        uint256 length = queuePosIds.length;\n\n        if (index >= length) revert(\"nothing to execute\");\n        if (endIndex > length) endIndex = length;\n\n        while (index < endIndex) {\n            uint256 t = queuePosIds[index];\n            uint256 orderType = t / 2 ** 128;\n            uint256 posId = t % 2 ** 128;\n\n            if (orderType == 0) {\n                try this.executeOpenMarketOrder(posId) {} catch Error(string memory err) {\n                    orderVault.cancelMarketOrder(posId);\n                    emit MarketOrderExecutionError(posId, positions[posId].owner, err);\n                } catch {\n                    orderVault.cancelMarketOrder(posId);\n                }\n            } else if (orderType == 1) {\n                try this.executeAddPositionOrder(posId) {} catch Error(string memory err) {\n                    orderVault.cancelAddPositionOrder(posId);\n                    emit AddPositionExecutionError(posId, positions[posId].owner, err);\n                } catch {\n                    orderVault.cancelAddPositionOrder(posId);\n                }\n            } else if (orderType == 2) {\n                try this.executeDecreasePositionOrder(posId) {} catch Error(string memory err) {\n                    orderVault.deleteDecreasePositionOrder(posId);\n                    emit DecreasePositionExecutionError(posId, positions[posId].owner, err);\n                } catch {\n                    orderVault.deleteDecreasePositionOrder(posId);\n                }\n            } else if (orderType == 3) {\n                try this.executeRemoveCollateral(posId) {} catch Error(string memory err) {\n                    delete removeCollateralOrders[posId];\n                    emit ExecuteRemoveCollateralError(posId, positions[posId].owner, err);\n                } catch {\n                    delete removeCollateralOrders[posId];\n                }\n            }\n\n            delete queuePosIds[index];\n            ++index;\n        }\n\n        queueIndex = index;\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n\n    function _increasePosition(\n        uint256 _posId,\n        address _account,\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _price,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        uint256 _fee\n    ) internal {\n        require(\n            !settingsManager.isIncreasingPositionDisabled(_tokenId),\n            \"current asset is disabled from increasing position\"\n        );\n\n        Position storage position = positions[_posId];\n\n        validateIncreasePosition(position.tokenId, position.collateral + _collateralDelta, position.size + _sizeDelta);\n\n        _price = settingsManager.getPriceWithSlippage(position.tokenId, position.isLong, _sizeDelta, _price);\n\n        settingsManager.updateFunding(_tokenId);\n        settingsManager.increaseOpenInterest(_tokenId, _account, _isLong, _sizeDelta);\n\n        if (position.size == 0) {\n            position.averagePrice = _price;\n            position.fundingIndex = settingsManager.fundingIndex(_tokenId);\n\n            _addUserAlivePosition(_account, _posId);\n        } else {\n            position.averagePrice =\n                (position.size * position.averagePrice + _sizeDelta * _price) /\n                (position.size + _sizeDelta);\n            position.fundingIndex =\n                (int256(position.size) *\n                    position.fundingIndex +\n                    int256(_sizeDelta) *\n                    settingsManager.fundingIndex(_tokenId)) /\n                int256(position.size + _sizeDelta);\n            position.accruedBorrowFee += settingsManager.getBorrowFee(\n                position.size,\n                position.lastIncreasedTime,\n                _tokenId,\n                _isLong\n            );\n\n            paidFees[_posId].paidPositionFee += _fee;\n        }\n\n        position.collateral += _collateralDelta;\n        position.size += _sizeDelta;\n        position.lastIncreasedTime = block.timestamp;\n\n        vault.distributeFee(_fee, position.refer, _account);\n\n        emit IncreasePosition(\n            _posId,\n            _account,\n            _tokenId,\n            _isLong,\n            [_collateralDelta, _sizeDelta, position.averagePrice, _price, _fee]\n        );\n    }\n\n    function increasePosition(\n        uint256 _posId,\n        address _account,\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _price,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        uint256 _fee\n    ) external override onlyOrderVault {\n        _increasePosition(_posId, _account, _tokenId, _isLong, _price, _collateralDelta, _sizeDelta, _fee);\n    }\n\n    function _decreasePosition(uint256 _posId, uint256 _price, uint256 _sizeDelta) internal {\n        Position storage position = positions[_posId];\n\n        require(\n            !settingsManager.isDecreasingPositionDisabled(position.tokenId),\n            \"current asset is disabled from decreasing position\"\n        );\n        require(position.size > 0, \"position size is zero\");\n        require(_sizeDelta > 0, \"_sizeDelta is zero\");\n        require(block.timestamp > position.lastIncreasedTime + settingsManager.closeDeltaTime(), \"!closeDeltaTime\");\n\n        if (_sizeDelta >= position.size) _sizeDelta = position.size;\n\n        _price = settingsManager.getPriceWithSlippage(position.tokenId, !position.isLong, _sizeDelta, _price); // decreasePosition is in opposite direction\n\n        settingsManager.updateFunding(position.tokenId);\n        settingsManager.decreaseOpenInterest(position.tokenId, position.owner, position.isLong, _sizeDelta);\n\n        uint256 countedBorrowFee;\n        if (position.accruedBorrowFee > 0) {\n            countedBorrowFee = (position.accruedBorrowFee * _sizeDelta) / position.size;\n            position.accruedBorrowFee -= countedBorrowFee;\n        }\n\n        (int256 pnl, int256 fundingFee, int256 borrowFee) = settingsManager.getPnl(\n            position.tokenId,\n            position.isLong,\n            _sizeDelta,\n            position.averagePrice,\n            _price,\n            position.lastIncreasedTime,\n            countedBorrowFee,\n            position.fundingIndex\n        );\n\n        uint256 fee = settingsManager.getTradingFee(position.owner, position.tokenId, !position.isLong, _sizeDelta);\n\n        uint256 collateralDelta = (position.collateral * _sizeDelta) / position.size;\n\n        int256 usdOut = int256(collateralDelta) + pnl - int256(fee);\n        if (usdOut > 0) vault.takeVUSDOut(position.owner, uint256(usdOut));\n\n        if (pnl >= 0) {\n            if (block.timestamp - position.lastIncreasedTime < settingsManager.minProfitDurations(position.tokenId)) {\n                uint256 profitPercent = (BASIS_POINTS_DIVISOR * uint256(pnl)) / collateralDelta;\n                if (\n                    profitPercent > settingsManager.maxCloseProfitPercents(position.tokenId) ||\n                    uint256(pnl) > settingsManager.maxCloseProfits(position.tokenId)\n                ) {\n                    revert(\"min profit duration not yet passed\");\n                }\n            }\n\n            vault.accountDeltaIntoTotalUSD(false, uint256(pnl));\n        } else {\n            uint256 loss = uint256(-1 * pnl);\n            uint256 maxLoss = collateralDelta - fee;\n            if (loss > maxLoss) {\n                vault.accountDeltaIntoTotalUSD(true, maxLoss);\n            } else {\n                vault.accountDeltaIntoTotalUSD(true, loss);\n            }\n        }\n\n        vault.distributeFee(fee, position.refer, position.owner);\n\n        // split fundingFee & borrowFee with vault & feeManager\n        {\n            int256 totalFees = fundingFee + borrowFee;\n            if (totalFees >= 0) {\n                uint256 totalFeesForFeeManager = (uint256(totalFees) *\n                    (BASIS_POINTS_DIVISOR - settingsManager.feeRewardBasisPoints())) / BASIS_POINTS_DIVISOR;\n                // take out accounted fees from vault and send to feeManager\n                vault.accountDeltaIntoTotalUSD(false, totalFeesForFeeManager);\n                vault.takeVUSDOut(settingsManager.feeManager(), totalFeesForFeeManager);\n            } else {\n                uint256 totalFeesForFeeManager = (uint256(-1 * totalFees) *\n                    (BASIS_POINTS_DIVISOR - settingsManager.feeRewardBasisPoints())) / BASIS_POINTS_DIVISOR;\n                // take out fees from feeManager and send to vault\n                vault.accountDeltaIntoTotalUSD(true, totalFeesForFeeManager);\n                vault.takeVUSDIn(settingsManager.feeManager(), totalFeesForFeeManager);\n            }\n        }\n\n        if (_sizeDelta < position.size) {\n            position.size -= _sizeDelta;\n            position.collateral -= collateralDelta;\n            paidFees[_posId].paidPositionFee += fee;\n            paidFees[_posId].paidBorrowFee += uint256(borrowFee);\n            paidFees[_posId].paidFundingFee += fundingFee;\n\n            Temp memory temp = Temp({a: collateralDelta, b: _sizeDelta, c: position.averagePrice, d: _price, e: fee}); // use struct to prevent stack too deep error\n            emit DecreasePosition(\n                _posId,\n                position.owner,\n                position.tokenId,\n                position.isLong,\n                [pnl, fundingFee, borrowFee],\n                [temp.a, temp.b, temp.c, temp.d, temp.e]\n            );\n        } else {\n            Temp memory temp = Temp({a: collateralDelta, b: _sizeDelta, c: position.averagePrice, d: _price, e: fee}); // use struct to prevent stack too deep error\n            emit ClosePosition(\n                _posId,\n                position.owner,\n                position.tokenId,\n                position.isLong,\n                [pnl, fundingFee, borrowFee],\n                [temp.a, temp.b, temp.c, temp.d, temp.e]\n            );\n\n            _removeUserAlivePosition(position.owner, _posId);\n        }\n    }\n\n    // for vault to directly close user's position in forceClosePosition()\n    function decreasePosition(uint256 _posId, uint256 _price, uint256 _sizeDelta) external override onlyVault {\n        _decreasePosition(_posId, _price, _sizeDelta);\n    }\n\n    function decreasePositionByOrderVault(\n        uint256 _posId,\n        uint256 _price,\n        uint256 _sizeDelta\n    ) external override onlyOrderVault {\n        _decreasePosition(_posId, _price, _sizeDelta);\n    }\n\n    function _addUserAlivePosition(address _user, uint256 _posId) internal {\n        userAliveIndexOf[_posId] = userPositionIds[_user].length;\n        userPositionIds[_user].push(_posId);\n    }\n\n    function _addUserOpenOrder(address _user, uint256 _posId) internal {\n        userOpenOrderIndexOf[_posId] = userOpenOrderIds[_user].length;\n        userOpenOrderIds[_user].push(_posId);\n    }\n\n    function removeUserAlivePosition(address _user, uint256 _posId) external override onlyLiquidateVault {\n        _removeUserAlivePosition(_user, _posId);\n    }\n\n    function _removeUserAlivePosition(address _user, uint256 _posId) internal {\n        uint256 index = userAliveIndexOf[_posId];\n        uint256 lastIndex = userPositionIds[_user].length - 1;\n        uint256 lastId = userPositionIds[_user][lastIndex];\n        delete positions[_posId];\n        userAliveIndexOf[lastId] = index;\n        delete userAliveIndexOf[_posId];\n\n        userPositionIds[_user][index] = lastId;\n        userPositionIds[_user].pop();\n\n        orderVault.cancelAddPositionOrder(_posId);\n    }\n\n    function removeUserOpenOrder(address _user, uint256 _posId) external override onlyOrderVault {\n        _removeUserOpenOrder(_user, _posId);\n    }\n\n    function _removeUserOpenOrder(address _user, uint256 _posId) internal {\n        uint256 index = userOpenOrderIndexOf[_posId];\n        uint256 lastIndex = userOpenOrderIds[_user].length - 1;\n        uint256 lastId = userOpenOrderIds[_user][lastIndex];\n        userOpenOrderIndexOf[lastId] = index;\n        delete userOpenOrderIndexOf[_posId];\n        userOpenOrderIds[_user][index] = lastId;\n        userOpenOrderIds[_user].pop();\n    }\n\n    /* ========== VALIDATE FUNCTIONS ========== */\n\n    function validateIncreasePosition(uint256 _tokenId, uint256 _collateral, uint256 _size) internal view {\n        require(_collateral >= settingsManager.minCollateral(), \"!minCollateral\");\n        validateMinLeverage(_size, _collateral);\n        validateMaxLeverage(_tokenId, _size, _collateral);\n    }\n\n    function validateMinLeverage(uint256 _size, uint256 _collateral) internal pure {\n        require(_size >= _collateral, \"leverage cannot be less than 1\");\n    }\n\n    function validateMaxLeverage(uint256 _tokenId, uint256 _size, uint256 _collateral) internal view {\n        require(_size * MIN_LEVERAGE <= _collateral * priceManager.maxLeverage(_tokenId), \"maxLeverage exceeded\");\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function getPosition(uint256 _posId) external view override returns (Position memory) {\n        return positions[_posId];\n    }\n\n    function getUserPositionIds(address _account) external view override returns (uint256[] memory) {\n        return userPositionIds[_account];\n    }\n\n    function getUserOpenOrderIds(address _account) external view override returns (uint256[] memory) {\n        return userOpenOrderIds[_account];\n    }\n\n    function getPaidFees(uint256 _posId) external view override returns (PaidFees memory) {\n        return paidFees[_posId];\n    }\n\n    function getNumOfUnexecuted() external view returns (uint256) {\n        return queuePosIds.length - queueIndex;\n    }\n\n    function getVaultUSDBalance() external view override returns (uint256) {\n        return vault.getVaultUSDBalance();\n    }\n}"
    },
    "contracts/core/PriceManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IPriceManager.sol\";\nimport \"./interfaces/IOperators.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\nimport {Constants} from \"../access/Constants.sol\";\n\ncontract PriceManager is Constants, Initializable, IPriceManager {\n    IOperators public operators;\n    IPyth public pyth;\n\n    mapping(uint256 => Asset) public assets;\n    struct Asset {\n        string symbol;\n        bytes32 pythId;\n        uint256 price;\n        uint256 timestamp;\n        uint256 allowedStaleness;\n        uint256 allowedDeviation;\n        uint256 maxLeverage;\n        uint256 tokenDecimals; // for usd stablecoin only\n    }\n\n    mapping(address => uint256) public tokenAddressToAssetId; // for usd stablecoin\n\n    // an array to track valid assets\n    uint256[] private validAssetIds;\n\n    event SetAsset(\n        uint256 assetId,\n        string symbol,\n        bytes32 pythId,\n        uint256 price,\n        uint256 timestamp,\n        uint256 allowedStaleness,\n        uint256 allowedDeviation,\n        uint256 maxLeverage\n    );\n    event SetUsdAsset(\n        address tokenAddress,\n        uint256 assetId,\n        string symbol,\n        bytes32 pythId,\n        uint256 price,\n        uint256 timestamp,\n        uint256 allowedStaleness,\n        uint256 allowedDeviation,\n        uint256 tokenDecimals\n    );\n    event SetPrice(uint256 assetId, uint256 price, uint256 timestamp);\n\n    modifier onlyOperator(uint256 level) {\n        require(operators.getOperatorLevel(msg.sender) >= level, \"invalid operator\");\n        _;\n    }\n\n    function initialize(address _operators, address _pyth) public initializer {\n        require(AddressUpgradeable.isContract(_operators), \"operators invalid\");\n        require(AddressUpgradeable.isContract(_pyth), \"pyth invalid\");\n\n        operators = IOperators(_operators);\n        pyth = IPyth(_pyth);\n    }\n\n    function setAsset(\n        uint256 _assetId,\n        string calldata _symbol,\n        bytes32 _pythId,\n        uint256 _price,\n        uint256 _allowedStaleness,\n        uint256 _allowedDeviation,\n        uint256 _maxLeverage\n    ) external onlyOperator(3) {\n        require(_maxLeverage > MIN_LEVERAGE, \"Max Leverage should be greater than Min Leverage\");\n\n        // new asset\n        if (assets[_assetId].maxLeverage == 0) {\n            validAssetIds.push(_assetId);\n        }\n\n        assets[_assetId] = Asset({\n            symbol: _symbol,\n            pythId: _pythId,\n            price: _price,\n            timestamp: block.timestamp,\n            allowedStaleness: _allowedStaleness,\n            allowedDeviation: _allowedDeviation,\n            maxLeverage: _maxLeverage,\n            tokenDecimals: 0\n        });\n\n        emit SetAsset(\n            _assetId,\n            _symbol,\n            _pythId,\n            _price,\n            block.timestamp,\n            _allowedStaleness,\n            _allowedDeviation,\n            _maxLeverage\n        );\n    }\n\n    function batchSetAllowedDeviation(uint256[] memory _assetIds, uint256 _allowedDeviation) external onlyOperator(3) {\n        for(uint256 i; i<_assetIds.length; i++){\n            uint256 _assetId = _assetIds[i];\n            Asset memory asset = assets[_assetId];\n            require(asset.maxLeverage > 0, \"!newAsset\");\n            asset.allowedDeviation = _allowedDeviation;\n            assets[_assetId] = asset;\n            emit SetAsset(\n                _assetId,\n                asset.symbol,\n                asset.pythId,\n                asset.price,\n                asset.timestamp,\n                asset.allowedStaleness,\n                asset.allowedDeviation,\n                asset.maxLeverage\n            );\n        }\n    }\n\n    function batchSetAllowedStaleness(uint256[] memory _assetIds, uint256 _allowedStaleness) external onlyOperator(3) {\n        for(uint256 i; i<_assetIds.length; i++){\n            uint256 _assetId = _assetIds[i];\n            Asset memory asset = assets[_assetId];\n            require(asset.maxLeverage > 0, \"!newAsset\");\n            asset.allowedStaleness = _allowedStaleness;\n            assets[_assetId] = asset;\n            emit SetAsset(\n                _assetId,\n                asset.symbol,\n                asset.pythId,\n                asset.price,\n                asset.timestamp,\n                asset.allowedStaleness,\n                asset.allowedDeviation,\n                asset.maxLeverage\n            );\n        }\n    }\n\n    function batchSetMaxLeverage(uint256[] memory _assetIds, uint256 _maxLeverage) external onlyOperator(3) {\n        for(uint256 i; i<_assetIds.length; i++){\n            uint256 _assetId = _assetIds[i];\n            Asset memory asset = assets[_assetId];\n            require(asset.maxLeverage > 0, \"!newAsset\");\n            asset.maxLeverage = _maxLeverage;\n            assets[_assetId] = asset;\n            emit SetAsset(\n                _assetId,\n                asset.symbol,\n                asset.pythId,\n                asset.price,\n                asset.timestamp,\n                asset.allowedStaleness,\n                asset.allowedDeviation,\n                asset.maxLeverage\n            );\n        }\n    }\n\n    function setUsdAsset(\n        address _tokenAddress,\n        uint256 _assetId,\n        string calldata _symbol,\n        bytes32 _pythId,\n        uint256 _price,\n        uint256 _allowedStaleness,\n        uint256 _allowedDeviation,\n        uint256 _tokenDecimals\n    ) external onlyOperator(3) {\n        // new asset\n        if (assets[_assetId].tokenDecimals == 0) {\n            validAssetIds.push(_assetId);\n        }\n\n        tokenAddressToAssetId[_tokenAddress] = _assetId;\n        assets[_assetId] = Asset({\n            symbol: _symbol,\n            pythId: _pythId,\n            price: _price,\n            timestamp: block.timestamp,\n            allowedStaleness: _allowedStaleness,\n            allowedDeviation: _allowedDeviation,\n            maxLeverage: 0,\n            tokenDecimals: _tokenDecimals\n        });\n\n        emit SetUsdAsset(\n            _tokenAddress,\n            _assetId,\n            _symbol,\n            _pythId,\n            _price,\n            block.timestamp,\n            _allowedStaleness,\n            _allowedDeviation,\n            _tokenDecimals\n        );\n    }\n\n    function getPythLastPrice(uint256 _assetId, bool _requireFreshness) public view returns (uint256) {\n        PythStructs.Price memory priceInfo = pyth.getPriceUnsafe(assets[_assetId].pythId);\n        if (_requireFreshness) {\n            require(block.timestamp <= priceInfo.publishTime + assets[_assetId].allowedStaleness, \"price stale\");\n        }\n\n        uint256 price = uint256(uint64(priceInfo.price));\n        if (priceInfo.expo >= 0) {\n            uint256 exponent = uint256(uint32(priceInfo.expo));\n            return price * PRICE_PRECISION * (10 ** exponent);\n        } else {\n            uint256 exponent = uint256(uint32(-priceInfo.expo));\n            return (price * PRICE_PRECISION) / (10 ** exponent);\n        }\n    }\n\n    function getLastPrice(uint256 _assetId) public view override returns (uint256) {\n        uint256 price = assets[_assetId].price;\n        require(price > 0, \"invalid price\");\n\n        uint256 ts = assets[_assetId].timestamp;\n        uint256 allowedStaleness = assets[_assetId].allowedStaleness;\n        if (allowedStaleness == 0 || block.timestamp - ts <= allowedStaleness) {\n            // our price is fresh enough, return our answer\n            return price;\n        } else {\n            // our price is stale, try use on-chain price with freshness requirement\n            return getPythLastPrice(_assetId, true);\n        }\n    }\n\n    function setPrice(uint256 _assetId, uint256 _price, uint256 _ts) public onlyOperator(2) {\n        require(_ts > assets[_assetId].timestamp, \"already updated\");\n        bytes32 pythId = assets[_assetId].pythId;\n        if (pythId != bytes32(0)) {\n            //skip validation if pyth not enabled for this asset\n            uint256 priceOnChain = getPythLastPrice(_assetId, false);\n            uint256 deviation = _price > priceOnChain\n                ? ((_price - priceOnChain) * BASIS_POINTS_DIVISOR) / priceOnChain\n                : ((priceOnChain - _price) * BASIS_POINTS_DIVISOR) / priceOnChain;\n            require(deviation <= assets[_assetId].allowedDeviation, \"need update pyth price\");\n        }\n        assets[_assetId].price = _price;\n        assets[_assetId].timestamp = _ts;\n\n        emit SetPrice(_assetId, _price, _ts);\n    }\n\n    function tokenToUsd(address _token, uint256 _tokenAmount) external view override returns (uint256) {\n        uint256 assetId = tokenAddressToAssetId[_token];\n\n        return (_tokenAmount * getLastPrice(assetId)) / (10 ** assets[assetId].tokenDecimals);\n    }\n\n    function usdToToken(address _token, uint256 _usdAmount) external view override returns (uint256) {\n        uint256 assetId = tokenAddressToAssetId[_token];\n\n        return (_usdAmount * (10 ** assets[assetId].tokenDecimals)) / getLastPrice(assetId);\n    }\n\n    function getCurrentTime() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function maxLeverage(uint256 _assetId) external view override returns (uint256) {\n        return assets[_assetId].maxLeverage;\n    }\n\n    function getValidAssetIds() external view returns (uint256[] memory) {\n        return validAssetIds;\n    }\n}"
    },
    "contracts/core/Reader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPositionVault.sol\";\nimport \"./interfaces/IOrderVault.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/ISettingsManager.sol\";\n\nimport \"../staking/interfaces/ITokenFarm.sol\";\n\nimport {Constants} from \"../access/Constants.sol\";\nimport {OrderStatus, PositionTrigger, TriggerInfo, PaidFees} from \"./structs.sol\";\n\ncontract Reader is Constants, Initializable {\n    struct AccruedFees {\n        uint256 positionFee;\n        uint256 borrowFee;\n        int256 fundingFee;\n    }\n\n    IOrderVault private orderVault;\n    IPositionVault private positionVault;\n    ISettingsManager private settingsManager;\n    ITokenFarm private tokenFarm;\n    IVault private vault;\n    IERC20 private USDC;\n    IERC20 private vUSD;\n    IERC20 private vlp;\n    IERC20 private vela;\n    IERC20 private esVela;\n\n    function initialize(IPositionVault _positionVault, IOrderVault _orderVault, ISettingsManager _settingsManager) public initializer {\n        require(AddressUpgradeable.isContract(address(_positionVault)), \"positionVault invalid\");\n        require(AddressUpgradeable.isContract(address(_orderVault)), \"orderVault invalid\");\n        positionVault = _positionVault;\n        orderVault = _orderVault;\n        settingsManager = _settingsManager;\n    }\n\n    function initializeV2(ITokenFarm _tokenFarm) reinitializer(2) public {\n        tokenFarm = _tokenFarm; // first caller 2%, resolver 8% and leftover 90% to vlp\n        require(AddressUpgradeable.isContract(address(_tokenFarm)), \"tokenFarm invalid\");\n    }\n\n    function initializeV3(IVault _vault, IERC20 _USDC, IERC20 _vUSD, IERC20 _vlp, IERC20 _vela, IERC20 _esVela) reinitializer(3) public {\n        require(AddressUpgradeable.isContract(address(_esVela)), \"esVela invalid\");\n        require(AddressUpgradeable.isContract(address(_vault)), \"Vault invalid\");\n        require(AddressUpgradeable.isContract(address(_vela)), \"vela invalid\");\n        require(AddressUpgradeable.isContract(address(_vlp)), \"vlp invalid\");\n        require(AddressUpgradeable.isContract(address(_USDC)), \"USDC invalid\");\n        require(AddressUpgradeable.isContract(address(_vUSD)), \"vUSD invalid\");\n        esVela = _esVela;\n        vault = _vault;\n        vela = _vela;\n        vlp = _vlp;\n        USDC = _USDC;\n        vUSD = _vUSD;\n    }\n\n    function getUserAlivePositions(\n        address _user\n    )\n        public\n        view\n        returns (uint256[] memory, Position[] memory, Order[] memory, PositionTrigger[] memory, PaidFees[] memory, AccruedFees[] memory)\n    {\n        uint256[] memory posIds = positionVault.getUserPositionIds(_user);\n        uint256 length = posIds.length;\n        Position[] memory positions_ = new Position[](length);\n        Order[] memory orders_ = new Order[](length);\n        PositionTrigger[] memory triggers_ = new PositionTrigger[](length);\n        PaidFees[] memory paidFees_ = new PaidFees[](length);\n        AccruedFees[] memory accruedFees_ = new AccruedFees[](length);\n        for (uint i; i < length; ++i) {\n            uint256 posId = posIds[i];\n            positions_[i] = positionVault.getPosition(posId);\n            orders_[i] = orderVault.getOrder(posId);\n            triggers_[i] = orderVault.getTriggerOrderInfo(posId);\n            paidFees_[i] = positionVault.getPaidFees(posId);\n            accruedFees_[i] = getAccruedFee(posId);\n        }\n        return (posIds, positions_, orders_, triggers_, paidFees_, accruedFees_);\n    }\n\n    function getAccruedFee(uint256 _posId) internal view returns (AccruedFees memory){\n        Position memory position = positionVault.getPosition(_posId);\n        AccruedFees memory accruedFees;\n        accruedFees.positionFee = settingsManager.getTradingFee(position.owner, position.tokenId, position.isLong, position.size);\n        accruedFees.borrowFee = settingsManager.getBorrowFee(position.size, position.lastIncreasedTime, position.tokenId, position.isLong) + position.accruedBorrowFee;\n        accruedFees.fundingFee = settingsManager.getFundingFee(position.tokenId, position.isLong, position.size, position.fundingIndex);\n        return accruedFees;\n    }\n\n    function getGlobalInfo(\n        address _account,\n        uint256 _tokenId\n    )\n        external\n        view\n        returns (\n            int256 fundingRate,\n            uint256 borrowRateForLong,\n            uint256 borrowRateForShort,\n            uint256 longOpenInterest,\n            uint256 shortOpenInterest,\n            uint256 maxLongOpenInterest,\n            uint256 maxShortOpenInterest,\n            uint256 longTradingFee,\n            uint256 shortTradingFee\n        )\n    {\n        fundingRate = settingsManager.getFundingRate(_tokenId);\n        borrowRateForLong = settingsManager.getBorrowRate(_tokenId, true);\n        borrowRateForShort = settingsManager.getBorrowRate(_tokenId, false);\n        longOpenInterest = settingsManager.openInterestPerAssetPerSide(_tokenId, true);\n        shortOpenInterest = settingsManager.openInterestPerAssetPerSide(_tokenId, false);\n        maxLongOpenInterest = settingsManager.maxOpenInterestPerAssetPerSide(_tokenId, true);\n        maxShortOpenInterest = settingsManager.maxOpenInterestPerAssetPerSide(_tokenId, false);\n        longTradingFee = settingsManager.getTradingFee(_account, _tokenId, true, PRICE_PRECISION);\n        shortTradingFee = settingsManager.getTradingFee(_account, _tokenId, false, PRICE_PRECISION);\n    }\n\n    function getUserOpenOrders(\n        address _user\n    )\n        public\n        view\n        returns (uint256[] memory, Position[] memory, Order[] memory, PositionTrigger[] memory, PaidFees[] memory, AccruedFees[] memory)\n    {\n        uint256[] memory posIds = positionVault.getUserOpenOrderIds(_user);\n        uint256 length = posIds.length;\n        Position[] memory positions_ = new Position[](length);\n        Order[] memory orders_ = new Order[](length);\n        PositionTrigger[] memory triggers_ = new PositionTrigger[](length);\n        PaidFees[] memory paidFees_ = new PaidFees[](length);\n        AccruedFees[] memory accruedFees_ = new AccruedFees[](length);\n        for (uint i; i < length; ++i) {\n            uint256 posId = posIds[i];\n            positions_[i] = positionVault.getPosition(posId);\n            orders_[i] = orderVault.getOrder(posId);\n            triggers_[i] = orderVault.getTriggerOrderInfo(posId);\n            paidFees_[i] = positionVault.getPaidFees(posId);\n            accruedFees_[i] = getAccruedFee(posId);\n        }\n        return (posIds, positions_, orders_, triggers_, paidFees_, accruedFees_);\n    }\n\n    function getFeesFor1CT(address _normal, address _oneCT) external view returns (bool, uint256) {\n        uint256 tierVelaPercent = tokenFarm.getTierVela(_normal);\n        uint256 deductFeePercentForNormal = settingsManager.deductFeePercent(_normal);\n        uint256 deductFeePercentForOneCT = settingsManager.deductFeePercent(_oneCT);\n        if (tierVelaPercent * (BASIS_POINTS_DIVISOR - deductFeePercentForNormal) / BASIS_POINTS_DIVISOR != (BASIS_POINTS_DIVISOR - deductFeePercentForOneCT)) {\n            return (true, BASIS_POINTS_DIVISOR - tierVelaPercent * (BASIS_POINTS_DIVISOR - deductFeePercentForNormal) / BASIS_POINTS_DIVISOR);\n        } else {\n            return (false, 0);\n        }\n    }\n\n    function validateMaxOILimit(address _account, bool _isLong, uint256 _size, uint256 _tokenId) external view returns (uint256, uint256, uint256, uint8) {\n        uint256 _openInterestPerUser = settingsManager.openInterestPerUser(_account);\n        uint256 _maxOpenInterestPerUser = settingsManager.maxOpenInterestPerUser(_account);\n        uint256 tradingFee = settingsManager.getTradingFee(_account, _tokenId, _isLong, _size);\n        uint256 triggerGasFee = settingsManager.triggerGasFee();\n        uint256 marketOrderGasFee = settingsManager.marketOrderGasFee();\n        if (_maxOpenInterestPerUser == 0) _maxOpenInterestPerUser = settingsManager.defaultMaxOpenInterestPerUser();\n        if (_openInterestPerUser + _size > _maxOpenInterestPerUser)\n            return (triggerGasFee, marketOrderGasFee, tradingFee, 1);\n        uint256 _openInterestPerAssetPerSide = settingsManager.openInterestPerAssetPerSide(_tokenId, _isLong);\n        if (_openInterestPerAssetPerSide + _size > settingsManager.maxOpenInterestPerAssetPerSide(_tokenId, _isLong ))\n            return (triggerGasFee, marketOrderGasFee, tradingFee, 2);\n        return (triggerGasFee, marketOrderGasFee, tradingFee, 0);\n    }\n\n    function getUserBalances(address _account) external view returns (uint256 ethBalance, uint256 usdcBalance, uint256 usdcAllowance, uint256 vusdBalance) {\n        ethBalance = _account.balance;\n        usdcBalance = USDC.balanceOf(_account);\n        usdcAllowance = USDC.allowance(_account, address(vault));\n        vusdBalance = vUSD.balanceOf(_account);\n    }\n\n    function getUserVelaAndEsVelaInfo(address _account) external view returns (uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory) {\n        uint256[] memory balances = new uint256[](2);\n        uint256[] memory allowances = new uint256[](2);\n        uint256[] memory stakedAmounts = new uint256[](2);\n        balances[0] = vela.balanceOf(_account);\n        balances[1] = esVela.balanceOf(_account);\n        allowances[0] = vela.allowance(_account, address(tokenFarm));\n        allowances[1] = esVela.allowance(_account, address(tokenFarm));\n        (uint256 velaStakedAmount, uint256 esVelaStakedAmount) = tokenFarm.getStakedVela(_account);\n        stakedAmounts[0] = velaStakedAmount;\n        stakedAmounts[1] = esVelaStakedAmount;\n        (, , uint256[] memory decimals, uint256[] memory pendingTokens) = tokenFarm.pendingTokens(true, _account);\n        return (balances, allowances, decimals, pendingTokens, stakedAmounts);\n    }\n\n    function getUserVLPInfo(address _account) external view returns (uint256[] memory, uint256[] memory, uint256[] memory) {\n        uint256 balance = vlp.balanceOf(_account);\n        uint256 allowance = vlp.allowance(_account, address(tokenFarm));\n        uint256 vlpPrice = vault.getVLPPrice();\n        (uint256 vlpStakedAmount, uint256 startTimestamp) = tokenFarm.getStakedVLP(_account);\n        uint256 cooldownDuration = tokenFarm.cooldownDuration();\n        uint256[] memory vlpInfo = new uint256[](6);\n        vlpInfo[0] = balance;\n        vlpInfo[1] = allowance;\n        vlpInfo[2] = vlpStakedAmount;\n        vlpInfo[3] = vlpPrice;\n        vlpInfo[4] = startTimestamp;\n        vlpInfo[5] = cooldownDuration;\n        (, , uint256[] memory decimals, uint256[] memory pendingTokens) = tokenFarm.pendingTokens(false, _account);\n        return (vlpInfo, decimals, pendingTokens);\n    }\n\n    function getUserVestingInfo(address _account) external view returns (uint256, uint256) {\n        uint256 totalVestedAmount = tokenFarm.getTotalVested(_account);\n        uint256 vestingClaimableAmount = tokenFarm.claimable(_account);\n        return (totalVestedAmount, vestingClaimableAmount);\n    }\n}"
    },
    "contracts/core/ReaderV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IPositionVault.sol\";\nimport \"./interfaces/IOrderVault.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/ISettingsManager.sol\";\n\nimport \"../staking/interfaces/ITokenFarm.sol\";\n\nimport {Constants} from \"../access/Constants.sol\";\nimport {OrderStatus, PositionTrigger, TriggerInfo, PaidFees} from \"./structs.sol\";\n\ncontract ReaderV2 is Constants, Initializable {\n    struct AccruedFees {\n        uint256 positionFee;\n        uint256 borrowFee;\n        int256 fundingFee;\n    }\n\n    IOrderVault private orderVault;\n    IPositionVault private positionVault;\n    ISettingsManager private settingsManager;\n    ITokenFarm private tokenFarm;\n    IVault private vault;\n    IERC20 private USDC;\n    IERC20 private vUSD;\n    IERC20 private vlp;\n    IERC20 private vela;\n    IERC20 private esVela;\n\n    function initialize(\n        address _vault,\n        address _positionVault,\n        address _orderVault,\n        address _settingsManager,\n        address _tokenFarm,\n        address _esVela,\n        address _vela,\n        address _vlp,\n        address _usdc,\n        address _vusd\n    ) public initializer {\n        vault = IVault(_vault);\n        positionVault = IPositionVault(_positionVault);\n        orderVault = IOrderVault(_orderVault);\n        settingsManager = ISettingsManager(_settingsManager);\n        tokenFarm = ITokenFarm(_tokenFarm);\n        esVela = IERC20(_esVela);\n        vela = IERC20(_vela);\n        vlp = IERC20(_vlp);\n        USDC = IERC20(_usdc);\n        vUSD = IERC20(_vusd);\n    }\n\n    function getUserAlivePositions(\n        address _user\n    )\n        public\n        view\n        returns (uint256[] memory, Position[] memory, Order[] memory, PositionTrigger[] memory, PaidFees[] memory, AccruedFees[] memory)\n    {\n        uint256[] memory posIds = positionVault.getUserPositionIds(_user);\n        uint256 length = posIds.length;\n        Position[] memory positions_ = new Position[](length);\n        Order[] memory orders_ = new Order[](length);\n        PositionTrigger[] memory triggers_ = new PositionTrigger[](length);\n        PaidFees[] memory paidFees_ = new PaidFees[](length);\n        AccruedFees[] memory accruedFees_ = new AccruedFees[](length);\n        for (uint i; i < length; ++i) {\n            uint256 posId = posIds[i];\n            positions_[i] = positionVault.getPosition(posId);\n            orders_[i] = orderVault.getOrder(posId);\n            triggers_[i] = orderVault.getTriggerOrderInfo(posId);\n            paidFees_[i] = positionVault.getPaidFees(posId);\n            accruedFees_[i] = getAccruedFee(posId);\n        }\n        return (posIds, positions_, orders_, triggers_, paidFees_, accruedFees_);\n    }\n\n    function getAccruedFee(uint256 _posId) internal view returns (AccruedFees memory){\n        Position memory position = positionVault.getPosition(_posId);\n        AccruedFees memory accruedFees;\n        accruedFees.positionFee = settingsManager.getTradingFee(position.owner, position.tokenId, position.isLong, position.size);\n        accruedFees.borrowFee = settingsManager.getBorrowFee(position.size, position.lastIncreasedTime, position.tokenId, position.isLong) + position.accruedBorrowFee;\n        accruedFees.fundingFee = settingsManager.getFundingFee(position.tokenId, position.isLong, position.size, position.fundingIndex);\n        return accruedFees;\n    }\n\n    function getGlobalInfo(\n        address _account,\n        uint256 _tokenId\n    )\n        external\n        view\n        returns (\n            int256 fundingRate,\n            uint256 borrowRateForLong,\n            uint256 borrowRateForShort,\n            uint256 longOpenInterest,\n            uint256 shortOpenInterest,\n            uint256 maxLongOpenInterest,\n            uint256 maxShortOpenInterest,\n            uint256 longTradingFee,\n            uint256 shortTradingFee\n        )\n    {\n        fundingRate = settingsManager.getFundingRate(_tokenId);\n        borrowRateForLong = settingsManager.getBorrowRate(_tokenId, true);\n        borrowRateForShort = settingsManager.getBorrowRate(_tokenId, false);\n        longOpenInterest = settingsManager.openInterestPerAssetPerSide(_tokenId, true);\n        shortOpenInterest = settingsManager.openInterestPerAssetPerSide(_tokenId, false);\n        maxLongOpenInterest = settingsManager.maxOpenInterestPerAssetPerSide(_tokenId, true);\n        maxShortOpenInterest = settingsManager.maxOpenInterestPerAssetPerSide(_tokenId, false);\n        longTradingFee = settingsManager.getTradingFee(_account, _tokenId, true, PRICE_PRECISION);\n        shortTradingFee = settingsManager.getTradingFee(_account, _tokenId, false, PRICE_PRECISION);\n    }\n\n    function getUserOpenOrders(\n        address _user\n    )\n        public\n        view\n        returns (uint256[] memory, Position[] memory, Order[] memory, PositionTrigger[] memory, PaidFees[] memory, AccruedFees[] memory)\n    {\n        uint256[] memory posIds = positionVault.getUserOpenOrderIds(_user);\n        uint256 length = posIds.length;\n        Position[] memory positions_ = new Position[](length);\n        Order[] memory orders_ = new Order[](length);\n        PositionTrigger[] memory triggers_ = new PositionTrigger[](length);\n        PaidFees[] memory paidFees_ = new PaidFees[](length);\n        AccruedFees[] memory accruedFees_ = new AccruedFees[](length);\n        for (uint i; i < length; ++i) {\n            uint256 posId = posIds[i];\n            positions_[i] = positionVault.getPosition(posId);\n            orders_[i] = orderVault.getOrder(posId);\n            triggers_[i] = orderVault.getTriggerOrderInfo(posId);\n            paidFees_[i] = positionVault.getPaidFees(posId);\n            accruedFees_[i] = getAccruedFee(posId);\n        }\n        return (posIds, positions_, orders_, triggers_, paidFees_, accruedFees_);\n    }\n\n    function getFeesFor1CT(address _normal, address _oneCT) external view returns (bool, uint256) {\n        uint256 tierVelaPercent = tokenFarm.getTierVela(_normal);\n        uint256 deductFeePercentForNormal = settingsManager.deductFeePercent(_normal);\n        uint256 deductFeePercentForOneCT = settingsManager.deductFeePercent(_oneCT);\n        if (tierVelaPercent * (BASIS_POINTS_DIVISOR - deductFeePercentForNormal) / BASIS_POINTS_DIVISOR != (BASIS_POINTS_DIVISOR - deductFeePercentForOneCT)) {\n            return (true, BASIS_POINTS_DIVISOR - tierVelaPercent * (BASIS_POINTS_DIVISOR - deductFeePercentForNormal) / BASIS_POINTS_DIVISOR);\n        } else {\n            return (false, 0);\n        }\n    }\n\n    function validateMaxOILimit(address _account, bool _isLong, uint256 _size, uint256 _tokenId) external view returns (uint256, uint256, uint256, uint8) {\n        uint256 _openInterestPerUser = settingsManager.openInterestPerUser(_account);\n        uint256 _maxOpenInterestPerUser = settingsManager.maxOpenInterestPerUser(_account);\n        uint256 tradingFee = settingsManager.getTradingFee(_account, _tokenId, _isLong, _size);\n        uint256 triggerGasFee = settingsManager.triggerGasFee();\n        uint256 marketOrderGasFee = settingsManager.marketOrderGasFee();\n        if (_maxOpenInterestPerUser == 0) _maxOpenInterestPerUser = settingsManager.defaultMaxOpenInterestPerUser();\n        if (_openInterestPerUser + _size > _maxOpenInterestPerUser)\n            return (triggerGasFee, marketOrderGasFee, tradingFee, 1);\n        uint256 _openInterestPerAssetPerSide = settingsManager.openInterestPerAssetPerSide(_tokenId, _isLong);\n        if (_openInterestPerAssetPerSide + _size > settingsManager.maxOpenInterestPerAssetPerSide(_tokenId, _isLong ))\n            return (triggerGasFee, marketOrderGasFee, tradingFee, 2);\n        return (triggerGasFee, marketOrderGasFee, tradingFee, 0);\n    }\n\n    function getSpread(uint256 _tokenId, uint256 _size) external view returns (uint256) {\n        uint256 slippageFactor = settingsManager.slippageFactor(_tokenId);\n        uint256 spread = settingsManager.getSlippage(slippageFactor, _size);\n        return spread;\n    }\n\n    function getUserBalances(address _account) external view returns (uint256 ethBalance, uint256 usdcBalance, uint256 usdcAllowance, uint256 vusdBalance) {\n        ethBalance = _account.balance;\n        usdcBalance = USDC.balanceOf(_account);\n        usdcAllowance = USDC.allowance(_account, address(vault));\n        vusdBalance = vUSD.balanceOf(_account);\n    }\n\n    function getUserVelaAndEsVelaInfo(address _account) external view returns (uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory) {\n        uint256[] memory balances = new uint256[](2);\n        uint256[] memory allowances = new uint256[](2);\n        uint256[] memory stakedAmounts = new uint256[](2);\n        balances[0] = vela.balanceOf(_account);\n        balances[1] = esVela.balanceOf(_account);\n        allowances[0] = vela.allowance(_account, address(tokenFarm));\n        allowances[1] = esVela.allowance(_account, address(tokenFarm));\n        (uint256 velaStakedAmount, uint256 esVelaStakedAmount) = tokenFarm.getStakedVela(_account);\n        stakedAmounts[0] = velaStakedAmount;\n        stakedAmounts[1] = esVelaStakedAmount;\n        (, , uint256[] memory decimals, uint256[] memory pendingTokens) = tokenFarm.pendingTokens(true, _account);\n        return (balances, allowances, decimals, pendingTokens, stakedAmounts);\n    }\n\n    function getUserVLPInfo(address _account) external view returns (uint256[] memory, uint256[] memory, uint256[] memory) {\n        uint256 balance = vlp.balanceOf(_account);\n        uint256 allowance = vlp.allowance(_account, address(tokenFarm));\n        uint256 vlpPrice = vault.getVLPPrice();\n        (uint256 vlpStakedAmount, uint256 startTimestamp) = tokenFarm.getStakedVLP(_account);\n        uint256 cooldownDuration = tokenFarm.cooldownDuration();\n        uint256[] memory vlpInfo = new uint256[](6);\n        vlpInfo[0] = balance;\n        vlpInfo[1] = allowance;\n        vlpInfo[2] = vlpStakedAmount;\n        vlpInfo[3] = vlpPrice;\n        vlpInfo[4] = startTimestamp;\n        vlpInfo[5] = cooldownDuration;\n        (, , uint256[] memory decimals, uint256[] memory pendingTokens) = tokenFarm.pendingTokens(false, _account);\n        return (vlpInfo, decimals, pendingTokens);\n    }\n\n    function getUserVestingInfo(address _account) external view returns (uint256, uint256) {\n        uint256 totalVestedAmount = tokenFarm.getTotalVested(_account);\n        uint256 vestingClaimableAmount = tokenFarm.claimable(_account);\n        return (totalVestedAmount, vestingClaimableAmount);\n    }\n}"
    },
    "contracts/core/SettingsManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/ISettingsManager.sol\";\nimport \"./interfaces/ILiquidateVault.sol\";\nimport \"./interfaces/IPositionVault.sol\";\nimport \"./interfaces/IOperators.sol\";\nimport \"../staking/interfaces/ITokenFarm.sol\";\nimport \"../tokens/interfaces/IVUSD.sol\";\nimport {Constants} from \"../access/Constants.sol\";\n\ncontract SettingsManager is ISettingsManager, Initializable, ReentrancyGuardUpgradeable, Constants {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // constants\n    ILiquidateVault public liquidateVault;\n    IPositionVault public positionVault;\n    ITokenFarm public tokenFarm;\n    IOperators public operators;\n    address public vusd;\n\n    /* ========== VAULT SETTINGS ========== */\n    uint256 public override cooldownDuration;\n    mapping(address => bool) public override isWhitelistedFromCooldown;\n    uint256 public override feeRewardBasisPoints;\n    address public override feeManager;\n    uint256 public override defaultMaxProfitPercent;\n\n    event SetCooldownDuration(uint256 cooldownDuration);\n    event SetIsWhitelistedFromCooldown(address addr, bool isWhitelisted);\n    event SetIsWhitelistedFromTransferCooldown(address addr, bool isWhitelisted);\n    event SetFeeRewardBasisPoints(uint256 feeRewardBasisPoints);\n    event SetFeeManager(address indexed feeManager);\n    event SetDefaultMaxProfitPercent(uint256 defaultMaxProfitPercent);\n    event SetMaxProfitPercent(uint256 tokenId, uint256 maxProfitPercent);\n    event SetMaxTotalVlp(uint256 maxTotalVlp);\n\n    /* ========== VAULT SWITCH ========== */\n    mapping(address => bool) public override isDeposit;\n    mapping(address => bool) public override isWithdraw;\n    mapping(address => bool) public override isStakingEnabled;\n    mapping(address => bool) public override isUnstakingEnabled;\n\n    event SetEnableDeposit(address indexed token, bool isEnabled);\n    event SetEnableWithdraw(address indexed token, bool isEnabled);\n    event SetEnableStaking(address indexed token, bool isEnabled);\n    event SetEnableUnstaking(address indexed token, bool isEnabled);\n\n    /* ========== VAULT FEE ========== */\n    mapping(address => uint256) public override depositFee;\n    mapping(address => uint256) public override withdrawFee;\n    mapping(address => uint256) public override stakingFee;\n    mapping(address => uint256) public override unstakingFee;\n\n    event SetDepositFee(address indexed token, uint256 indexed fee);\n    event SetWithdrawFee(address indexed token, uint256 indexed fee);\n    event SetStakingFee(address indexed token, uint256 indexed fee);\n    event SetUnstakingFee(address indexed token, uint256 indexed fee);\n\n    /* ========== TRADING FEE ========== */\n    mapping(uint256 => mapping(bool => uint256)) public override tradingFee; // 100 = 0.1%\n    mapping(address => uint256) public override deductFeePercent;\n\n    event SetTradingFee(uint256 indexed tokenId, bool isLong, uint256 tradingFee);\n    event SetDeductFeePercent(address indexed account, uint256 deductFee);\n\n    /* ========== FUNDING FEE ========== */\n    uint256 public override basisFundingRateFactor;\n    mapping(uint256 => uint256) public override fundingRateFactor;\n    uint256 public override maxFundingRate;\n\n    event SetBasisFundingRateFactor(uint256 basisFundingRateFactor);\n    event SetFundingRateFactor(uint256 indexed tokenId, uint256 fundingRateFactor);\n    event SetMaxFundingRate(uint256 maxFundingRateFactor);\n\n    event SetVolatilityFactor(uint256 indexed tokenId, uint256 volatilityFactor);\n    event SetLongBiasFactor(uint256 indexed tokenId, uint256 longBiasFactor);\n    event SetFundingRateVelocityFactor(uint256 indexed tokenId, uint256 fundingRateVelocityFactor);\n    event SetTempMaxFundingRateFactor(uint256 indexed tokenId, uint256 tempMaxFundingRateFactor);\n\n    mapping(uint256 => int256) public override fundingIndex;\n    mapping(uint256 => uint256) public override lastFundingTimes;\n\n    event UpdateFunding(uint256 indexed tokenId, int256 fundingIndex);\n\n    /* ========== BORROW FEE ========== */\n    uint256 public override defaultBorrowFeeFactor; // deprecated\n    mapping(uint256 => uint256) public override borrowFeeFactor; // deprecated\n\n    event SetBorrowFeeFactorPerAssetPerSide(uint256 tokenId, bool isLong, uint256 borrowFeeFactor);\n\n    /* ========== REFER FEE ========== */\n    mapping(address => uint256) public override referrerTiers;\n    mapping(uint256 => uint256) public override tierFees;\n\n    event SetReferrerTier(address referrer, uint256 tier);\n    event SetTierFee(uint256 tier, uint256 fee);\n    event SetTierRebate(uint256 tier, uint256 rebate);\n    event SetPlatformFee(address platform, uint256 fee);\n\n    /* ========== INCREASE/DECREASE POSITION ========== */\n    mapping(uint256 => bool) public override isIncreasingPositionDisabled;\n    mapping(uint256 => bool) public override isDecreasingPositionDisabled;\n    uint256 public override minCollateral;\n    uint256 public override closeDeltaTime;\n\n    event SetIsIncreasingPositionDisabled(uint256 tokenId, bool isDisabled);\n    event SetIsDecreasingPositionDisabled(uint256 tokenId, bool isDisabled);\n    event SetMinCollateral(uint256 minCollateral);\n    event SetCloseDeltaTime(uint256 deltaTime);\n    event SetMinProfitDuration(uint256 tokenId, uint256 minProfitDuration);\n    event SetMaxCloseProfit(uint256 tokenId, uint256 maxCloseProfit);\n    event SetMaxCloseProfitPercent(uint256 tokenId, uint256 maxCloseProfitPercent);\n\n    /* ========== OPEN INTEREST MECHANISM ========== */\n    uint256 public defaultMaxOpenInterestPerUser;\n    mapping(address => uint256) public maxOpenInterestPerUser;\n    mapping(uint256 => mapping(bool => uint256)) public maxOpenInterestPerAssetPerSide;\n\n    event SetDefaultMaxOpenInterestPerUser(uint256 maxOIAmount);\n    event SetMaxOpenInterestPerUser(address indexed account, uint256 maxOIAmount);\n    event SetMaxOpenInterestPerAssetPerSide(uint256 indexed tokenId, bool isLong, uint256 maxOIAmount);\n    event SetMaxTotalOpenInterest(uint256 maxOIAmount);\n\n    mapping(address => uint256) public override openInterestPerUser;\n    mapping(uint256 => mapping(bool => uint256)) public override openInterestPerAssetPerSide;\n    uint256 public override totalOpenInterest;\n\n    event IncreaseOpenInterest(uint256 indexed id, bool isLong, uint256 amount);\n    event DecreaseOpenInterest(uint256 indexed id, bool isLong, uint256 amount);\n\n    /* ========== MARKET ORDER ========== */\n    uint256 public override marketOrderGasFee;\n    uint256 public override expiryDuration;\n    uint256 public override selfExecuteCooldown;\n\n    event SetMarketOrderGasFee(uint256 indexed fee);\n    event SetExpiryDuration(uint256 expiryDuration);\n    event SetSelfExecuteCooldown(uint256 selfExecuteCooldown);\n\n    /* ========== TRIGGER ORDER ========== */\n    uint256 public override triggerGasFee;\n    uint256 public override maxTriggerPerPosition;\n    uint256 public override priceMovementPercent;\n\n    event SetTriggerGasFee(uint256 indexed fee);\n    event SetMaxTriggerPerPosition(uint256 value);\n    event SetPriceMovementPercent(uint256 priceMovementPercent);\n\n    /* ========== ARTIFICIAL SLIPPAGE MECHANISM ========== */\n    mapping(uint256 => uint256) public override slippageFactor;\n\n    event SetSlippageFactor(uint256 indexed tokenId, uint256 slippageFactor);\n\n    /* ========== LIQUIDATE MECHANISM ========== */\n    mapping(uint256 => uint256) public liquidateThreshold;\n    uint256 public override liquidationPendingTime;\n    uint256 private unused; // removal of liquidationFee\n    struct BountyPercent {\n        uint32 firstCaller;\n        uint32 resolver;\n    } // pack to save gas\n    BountyPercent private bountyPercent_;\n\n    event SetLiquidateThreshold(uint256 indexed tokenId, uint256 newThreshold);\n    event SetLiquidationPendingTime(uint256 liquidationPendingTime);\n    event SetBountyPercent(uint32 bountyPercentFirstCaller, uint32 bountyPercentResolver);\n\n    /* ========== DELEGATE MECHANISM========== */\n    mapping(address => EnumerableSetUpgradeable.AddressSet) private _delegatesByMaster;\n    mapping(address => bool) public globalDelegates; // treat these addrs already be delegated\n\n    event GlobalDelegatesChange(address indexed delegate, bool allowed);\n\n    /* ========== BAN MECHANISM========== */\n    EnumerableSetUpgradeable.AddressSet private banWalletList;\n\n    /* new variables */\n    mapping(address => bool) public override isWhitelistedFromTransferCooldown;\n    mapping(uint256 => uint256) public override maxProfitPercent;\n    uint256 public maxTotalOpenInterest;\n    mapping(uint256 => mapping(bool => uint256)) public borrowFeeFactorPerAssetPerSide;\n    mapping(uint256 => uint256) public tierRebates; // tier => rebate percent for trader\n    mapping(address => uint256) public override platformFees; // address of 3rd platform to receive platform fee => fee percent\n    uint256 public override maxTotalVlp;\n\n    mapping(uint256 => uint256) public override minProfitDurations; // tokenId => minProfitDuration\n    mapping(uint256 => uint256) public override maxCloseProfits; // tokenId => maxCloseProfit\n    mapping(uint256 => uint256) public override maxCloseProfitPercents; // tokenId => maxCloseProfitPercent\n\n    mapping(uint256 => int256) public override lastFundingRates; // tokenId => last updated funding rate\n    mapping(uint256 => uint256) public override volatilityFactors; // tokenId => volatilityFactor\n    mapping(uint256 => uint256) public override longBiasFactors; // tokenId => longBiasFactors\n    mapping(uint256 => uint256) public override fundingRateVelocityFactors; // tokenId => fundingRateVelocityFactor\n    mapping(uint256 => uint256) public override tempMaxFundingRateFactors; // tokenId => tempMaxFundingRateFactor\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyVault() {\n        require(msg.sender == address(positionVault) || msg.sender == address(liquidateVault), \"Only vault\");\n        _;\n    }\n\n    modifier onlyOperator(uint256 level) {\n        _onlyOperator(level);\n        _;\n    }\n\n    function _onlyOperator(uint256 level) private view {\n        require(operators.getOperatorLevel(msg.sender) >= level, \"invalid operator\");\n    }\n\n    /* ========== INITIALIZE FUNCTION========== */\n    function initialize(\n        address _liquidateVault,\n        address _positionVault,\n        address _operators,\n        address _vusd,\n        address _tokenFarm\n    ) public initializer {\n        __ReentrancyGuard_init();\n        liquidateVault = ILiquidateVault(_liquidateVault);\n        positionVault = IPositionVault(_positionVault);\n        operators = IOperators(_operators);\n        tokenFarm = ITokenFarm(_tokenFarm);\n        vusd = _vusd;\n        priceMovementPercent = 50; // 0.05%\n        defaultMaxProfitPercent = 10000; // 10%\n        bountyPercent_ = BountyPercent({firstCaller: 20000, resolver: 50000}); // first caller 20%, resolver 50% and leftover to team\n        liquidationPendingTime = 10; // allow 10 seconds for manager to resolve liquidation\n        cooldownDuration = 3 hours;\n        expiryDuration = 60; // 60 seconds\n        selfExecuteCooldown = 60; // 60 seconds\n        feeRewardBasisPoints = 50000; // 50%\n        minCollateral = 5 * PRICE_PRECISION; // min 5 USD\n        defaultBorrowFeeFactor = 10; // 0.01% per hour\n        triggerGasFee = 0; //100 gwei;\n        marketOrderGasFee = 0;\n        basisFundingRateFactor = 10000;\n        tierFees[0] = 5000; // 5% refer fee for default tier\n        maxTriggerPerPosition = 10;\n        defaultMaxOpenInterestPerUser = 10000000000000000 * PRICE_PRECISION;\n        maxFundingRate = FUNDING_RATE_PRECISION / 100; // 1% per hour\n        maxTotalOpenInterest = 10000000000 * PRICE_PRECISION;\n        unused = 10000; // 10%\n        maxTotalVlp = 20 * 10 ** 6 * 10 ** VLP_DECIMALS; // 20mil max vlp supply\n    }\n\n    function initializeV2() public reinitializer(2) {\n        bountyPercent_ = BountyPercent({firstCaller: 2000, resolver: 8000}); // first caller 2%, resolver 8% and leftover 90% to vlp\n    }\n\n    function initializeV3() public reinitializer(3) {\n        maxTotalOpenInterest = 10000000000 * PRICE_PRECISION;\n        defaultBorrowFeeFactor = 100; // 0.01% per hour\n    }\n\n    /* ========== VAULT SETTINGS ========== */\n    /* OP FUNCTIONS */\n    function setCooldownDuration(uint256 _cooldownDuration) external onlyOperator(3) {\n        require(_cooldownDuration <= MAX_COOLDOWN_DURATION, \"invalid cooldownDuration\");\n        cooldownDuration = _cooldownDuration;\n        emit SetCooldownDuration(_cooldownDuration);\n    }\n\n    function setIsWhitelistedFromCooldown(address _addr, bool _isWhitelisted) external onlyOperator(3) {\n        isWhitelistedFromCooldown[_addr] = _isWhitelisted;\n        emit SetIsWhitelistedFromCooldown(_addr, _isWhitelisted);\n    }\n\n    function setIsWhitelistedFromTransferCooldown(address _addr, bool _isWhitelisted) external onlyOperator(3) {\n        isWhitelistedFromTransferCooldown[_addr] = _isWhitelisted;\n        emit SetIsWhitelistedFromTransferCooldown(_addr, _isWhitelisted);\n    }\n\n    function setFeeRewardBasisPoints(uint256 _feeRewardsBasisPoints) external onlyOperator(3) {\n        require(_feeRewardsBasisPoints <= BASIS_POINTS_DIVISOR, \"Above max\");\n        feeRewardBasisPoints = _feeRewardsBasisPoints;\n        emit SetFeeRewardBasisPoints(_feeRewardsBasisPoints);\n    }\n\n    function setFeeManager(address _feeManager) external onlyOperator(3) {\n        feeManager = _feeManager;\n        emit SetFeeManager(_feeManager);\n    }\n\n    function setDefaultMaxProfitPercent(uint256 _defaultMaxProfitPercent) external onlyOperator(3) {\n        defaultMaxProfitPercent = _defaultMaxProfitPercent;\n        emit SetDefaultMaxProfitPercent(_defaultMaxProfitPercent);\n    }\n\n    function setMaxProfitPercent(uint256 _tokenId, uint256 _maxProfitPercent) external onlyOperator(3) {\n        maxProfitPercent[_tokenId] = _maxProfitPercent;\n        emit SetMaxProfitPercent(_tokenId, _maxProfitPercent);\n    }\n\n    function setMaxTotalVlp(uint256 _maxTotalVlp) external onlyOperator(3) {\n        require(_maxTotalVlp > 0, \"invalid maxTotalVlp\");\n        maxTotalVlp = _maxTotalVlp;\n        emit SetMaxTotalVlp(_maxTotalVlp);\n    }\n\n    /* ========== VAULT SWITCH ========== */\n    /* OP FUNCTIONS */\n    function setEnableDeposit(address _token, bool _isEnabled) external onlyOperator(3) {\n        isDeposit[_token] = _isEnabled;\n        emit SetEnableDeposit(_token, _isEnabled);\n    }\n\n    function setEnableWithdraw(address _token, bool _isEnabled) external onlyOperator(3) {\n        isWithdraw[_token] = _isEnabled;\n        emit SetEnableWithdraw(_token, _isEnabled);\n    }\n\n    function setEnableStaking(address _token, bool _isEnabled) external onlyOperator(3) {\n        isStakingEnabled[_token] = _isEnabled;\n        emit SetEnableStaking(_token, _isEnabled);\n    }\n\n    function setEnableUnstaking(address _token, bool _isEnabled) external onlyOperator(3) {\n        isUnstakingEnabled[_token] = _isEnabled;\n        emit SetEnableUnstaking(_token, _isEnabled);\n    }\n\n    /* ========== VAULT FEE ========== */\n    /* OP FUNCTIONS */\n    function setDepositFee(address token, uint256 _fee) external onlyOperator(3) {\n        require(_fee <= MAX_DEPOSIT_WITHDRAW_FEE, \"Above max\");\n        depositFee[token] = _fee;\n        emit SetDepositFee(token, _fee);\n    }\n\n    function setWithdrawFee(address token, uint256 _fee) external onlyOperator(3) {\n        require(_fee <= MAX_DEPOSIT_WITHDRAW_FEE, \"Above max\");\n        withdrawFee[token] = _fee;\n        emit SetWithdrawFee(token, _fee);\n    }\n\n    function setStakingFee(address token, uint256 _fee) external onlyOperator(3) {\n        require(_fee <= MAX_STAKING_UNSTAKING_FEE, \"Above max\");\n        stakingFee[token] = _fee;\n        emit SetStakingFee(token, _fee);\n    }\n\n    function setUnstakingFee(address token, uint256 _fee) external onlyOperator(3) {\n        require(_fee <= MAX_STAKING_UNSTAKING_FEE, \"Above max\");\n        unstakingFee[token] = _fee;\n        emit SetUnstakingFee(token, _fee);\n    }\n\n    /* ========== TRADING FEE ========== */\n    /* OP FUNCTIONS */\n    function setTradingFee(uint256 _tokenId, bool _isLong, uint256 _tradingFee) external onlyOperator(3) {\n        require(_tradingFee <= MAX_FEE_BASIS_POINTS, \"Above max\");\n        tradingFee[_tokenId][_isLong] = _tradingFee;\n        emit SetTradingFee(_tokenId, _isLong, _tradingFee);\n    }\n\n    function setDeductFeePercentForUser(address _account, uint256 _deductFee) external onlyOperator(2) {\n        require(_deductFee <= BASIS_POINTS_DIVISOR, \"Above max\");\n        deductFeePercent[_account] = _deductFee;\n        emit SetDeductFeePercent(_account, _deductFee);\n    }\n\n    /* VIEW FUNCTIONS */\n    function getTradingFee(\n        address _account,\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _sizeDelta\n    ) external view override returns (uint256) {\n        return\n            (getUndiscountedTradingFee(_tokenId, _isLong, _sizeDelta) *\n                (BASIS_POINTS_DIVISOR - deductFeePercent[_account]) *\n                tokenFarm.getTierVela(_account)) / BASIS_POINTS_DIVISOR ** 2;\n    }\n\n    function getUndiscountedTradingFee(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _sizeDelta\n    ) public view override returns (uint256) {\n        return (_sizeDelta * tradingFee[_tokenId][_isLong]) / BASIS_POINTS_DIVISOR;\n    }\n\n    /* ========== FUNDING FEE ========== */\n    /* OP FUNCTIONS */\n    function setBasisFundingRateFactor(uint256 _basisFundingRateFactor) external onlyOperator(3) {\n        basisFundingRateFactor = _basisFundingRateFactor;\n        emit SetBasisFundingRateFactor(_basisFundingRateFactor);\n    }\n\n    function setFundingRateFactor(uint256 _tokenId, uint256 _fundingRateFactor) external onlyOperator(3) {\n        fundingRateFactor[_tokenId] = _fundingRateFactor;\n        emit SetFundingRateFactor(_tokenId, _fundingRateFactor);\n    }\n\n    function setMaxFundingRate(uint256 _maxFundingRate) external onlyOperator(3) {\n        require(_maxFundingRate <= MAX_FUNDING_RATE, \"Above max\");\n        maxFundingRate = _maxFundingRate;\n        emit SetMaxFundingRate(_maxFundingRate);\n    }\n\n    function setVolatilityFactor(uint256 _tokenId, uint256 _volatilityFactor) external onlyOperator(3) {\n        volatilityFactors[_tokenId] = _volatilityFactor;\n        emit SetVolatilityFactor(_tokenId, _volatilityFactor);\n    }\n\n    function setLongBiasFactor(uint256 _tokenId, uint256 _longBiasFactor) external onlyOperator(3) {\n        longBiasFactors[_tokenId] = _longBiasFactor;\n        emit SetLongBiasFactor(_tokenId, _longBiasFactor);\n    }\n\n    function setFundingRateVelocityFactor(\n        uint256 _tokenId,\n        uint256 _fundingRateVelocityFactor\n    ) external onlyOperator(3) {\n        fundingRateVelocityFactors[_tokenId] = _fundingRateVelocityFactor;\n        emit SetFundingRateVelocityFactor(_tokenId, _fundingRateVelocityFactor);\n    }\n\n    function setTempMaxFundingRateFactor(uint256 _tokenId, uint256 _tempMaxFundingRateFactor) external onlyOperator(3) {\n        tempMaxFundingRateFactors[_tokenId] = _tempMaxFundingRateFactor;\n        emit SetTempMaxFundingRateFactor(_tokenId, _tempMaxFundingRateFactor);\n    }\n\n    /* VAULT FUNCTIONS */\n    // to update the fundingIndex every time before open interest changes\n    function updateFunding(uint256 _tokenId) external override {\n        if (lastFundingTimes[_tokenId] == 0) {\n            require(msg.sender == address(positionVault), \"initialized by vault only\"); // can be initialized by vault only\n        } else {\n            int256 fundingRate = getFundingRate(_tokenId);\n            int256 latestFundingIndex = fundingIndex[_tokenId] + getFundingChange(_tokenId, fundingRate);\n            fundingIndex[_tokenId] = latestFundingIndex;\n\n            emit UpdateFunding(_tokenId, latestFundingIndex);\n\n            lastFundingRates[_tokenId] = fundingRate;\n        }\n\n        lastFundingTimes[_tokenId] = block.timestamp;\n    }\n\n    /* VIEW FUNCTIONS */\n    // calculate fundingFee based on fundingIndex difference\n    function getFundingFee(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _size,\n        int256 _fundingIndex\n    ) public view override returns (int256) {\n        return\n            _isLong\n                ? (int256(_size) * (getLatestFundingIndex(_tokenId) - _fundingIndex)) / int256(FUNDING_RATE_PRECISION)\n                : (int256(_size) * (_fundingIndex - getLatestFundingIndex(_tokenId))) / int256(FUNDING_RATE_PRECISION);\n    }\n\n    // calculate latestFundingIndex based on fundingChange\n    function getLatestFundingIndex(uint256 _tokenId) public view returns (int256) {\n        int256 fundingRate = getFundingRate(_tokenId);\n        return fundingIndex[_tokenId] + getFundingChange(_tokenId, fundingRate);\n    }\n\n    // calculate fundingChange based on fundingRate and period it has taken effect\n    // averageFundingRate is used to calc fundingChange as the fundingRate slowly changes over time due to fundingRateVelocity\n    function getFundingChange(uint256 _tokenId, int256 _fundingRate) private view returns (int256) {\n        uint256 interval = block.timestamp - lastFundingTimes[_tokenId];\n        if (interval == 0) return int256(0);\n\n        int256 lastFundingRate = lastFundingRates[_tokenId];\n        int256 averageFundingRate = (lastFundingRate + _fundingRate) / 2;\n\n        return (averageFundingRate * int256(interval)) / int256(1 hours);\n    }\n\n    // get temporary max funding rate with 1e15 decimals\n    function getTempMaxFundingRate(uint256 _tokenId) public view returns (uint256) {\n        return (tempMaxFundingRateFactors[_tokenId] * volatilityFactors[_tokenId]) * BASIS_POINTS_DIVISOR;\n    }\n\n    // calculate funding rate per hour with 1e15 decimals\n    function getFundingRate(uint256 _tokenId) public view override returns (int256) {\n        uint256 interval = block.timestamp - lastFundingTimes[_tokenId];\n        int256 fundingRate = lastFundingRates[_tokenId] +\n            (int256(interval) * getFundingRateVelocity(_tokenId)) /\n            int256(1 hours);\n\n        uint256 tempMaxFundingRate = getTempMaxFundingRate(_tokenId);\n        uint256 curMaxFundingRate = tempMaxFundingRate < maxFundingRate ? tempMaxFundingRate : maxFundingRate;\n\n        if (fundingRate == 0) return 0;\n\n        if (fundingRate > 0) {\n            int256 _curMaxFundingRate = int256(curMaxFundingRate);\n            if (fundingRate > _curMaxFundingRate) return _curMaxFundingRate;\n        } else {\n            int256 _curMaxFundingRate = -1 * int256(curMaxFundingRate);\n            if (fundingRate < _curMaxFundingRate) return _curMaxFundingRate;\n        }\n\n        return fundingRate;\n    }\n\n    // calculate velocity for funding rate with 1e15 decimals\n    function getFundingRateVelocity(uint256 _tokenId) public view returns (int256) {\n        uint256 longOI = openInterestPerAssetPerSide[_tokenId][true];\n        uint256 shortOI = openInterestPerAssetPerSide[_tokenId][false];\n        uint256 limitOI = maxOpenInterestPerAssetPerSide[_tokenId][true] +\n            maxOpenInterestPerAssetPerSide[_tokenId][false];\n        if (limitOI == 0) return 0;\n\n        // skewRatio = (longOI - shortOI) / limitOI\n        int256 skewRatio = (int256(BASIS_POINTS_DIVISOR) * (int256(longOI) - int256(shortOI))) / int256(limitOI);\n\n        int256 tempMaxFundingRate = int256(getTempMaxFundingRate(_tokenId));\n\n        int256 fundingRateVelocityFactor = int256(fundingRateVelocityFactors[_tokenId]);\n        if (fundingRateVelocityFactor == 0) return 0;\n\n        // fundingRateVelocity = [tempMaxFundingRate * (skewRatio + longBias) - lastFundingRate] / fundingRateVelocityFactor\n        return\n            (tempMaxFundingRate *\n                (skewRatio + int256(longBiasFactors[_tokenId])) -\n                lastFundingRates[_tokenId] *\n                int256(BASIS_POINTS_DIVISOR)) / fundingRateVelocityFactor;\n    }\n\n    /* ========== BORROW FEE ========== */\n    /* OP FUNCTIONS */\n    function setBorrowFeeFactorPerAssetPerSide(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _borrowFeeFactor\n    ) external onlyOperator(3) {\n        require(_borrowFeeFactor <= MAX_BORROW_FEE_FACTOR * 10, \"Above max\");\n        borrowFeeFactorPerAssetPerSide[_tokenId][_isLong] = _borrowFeeFactor;\n        emit SetBorrowFeeFactorPerAssetPerSide(_tokenId, _isLong, _borrowFeeFactor);\n    }\n\n    /* VIEW FUNCTIONS */\n    function getBorrowFee(\n        uint256 _borrowedSize,\n        uint256 _lastIncreasedTime,\n        uint256 _tokenId,\n        bool _isLong\n    ) public view override returns (uint256) {\n        return\n            ((block.timestamp - _lastIncreasedTime) * _borrowedSize * getBorrowRate(_tokenId, _isLong)) /\n            (BASIS_POINTS_DIVISOR * 10) /\n            1 hours;\n    }\n\n    // get borrow rate per hour with 1e6 decimals\n    function getBorrowRate(uint256 _tokenId, bool _isLong) public view returns (uint256) {\n        return borrowFeeFactorPerAssetPerSide[_tokenId][_isLong];\n    }\n\n    /* ========== REFER FEE ========== */\n    /* OP FUNCTIONS */\n    function setReferrerTier(address _referrer, uint256 _tier) external onlyOperator(1) {\n        referrerTiers[_referrer] = _tier;\n        emit SetReferrerTier(_referrer, _tier);\n    }\n\n    function setTierFee(uint256 _tier, uint256 _fee) external onlyOperator(3) {\n        require(_fee + tierRebates[_tier] <= BASIS_POINTS_DIVISOR, \"Above max\");\n        tierFees[_tier] = _fee;\n        emit SetTierFee(_tier, _fee);\n    }\n\n    function setTierRebate(uint256 _tier, uint256 _rebate) external onlyOperator(3) {\n        require(_rebate + tierFees[_tier] <= BASIS_POINTS_DIVISOR, \"Above max\");\n        tierRebates[_tier] = _rebate;\n        emit SetTierRebate(_tier, _rebate);\n    }\n\n    function setPlatformFee(address _platform, uint256 _fee) external onlyOperator(3) {\n        require(_fee <= BASIS_POINTS_DIVISOR, \"Above max\");\n        platformFees[_platform] = _fee;\n        emit SetPlatformFee(_platform, _fee);\n    }\n\n    /* VIEW FUNCTIONS */\n    function getReferFee(address _refer) external view override returns (uint256) {\n        return tierFees[referrerTiers[_refer]];\n    }\n\n    function getTraderRebate(address _refer) external view returns (uint256) {\n        return tierRebates[referrerTiers[_refer]];\n    }\n\n    function getReferFeeAndTraderRebate(\n        address _refer\n    ) external view override returns (uint256 referFee, uint256 traderRebate) {\n        uint256 tier = referrerTiers[_refer];\n\n        referFee = tierFees[tier];\n        traderRebate = tierRebates[tier];\n    }\n\n    /* ========== INCREASE/DECREASE POSITION ========== */\n    /* OP FUNCTIONS */\n    function setIsIncreasingPositionDisabled(uint256 _tokenId, bool _isDisabled) external onlyOperator(2) {\n        isIncreasingPositionDisabled[_tokenId] = _isDisabled;\n        emit SetIsIncreasingPositionDisabled(_tokenId, _isDisabled);\n    }\n\n    function setIsDecreasingPositionDisabled(uint256 _tokenId, bool _isDisabled) external onlyOperator(2) {\n        isDecreasingPositionDisabled[_tokenId] = _isDisabled;\n        emit SetIsDecreasingPositionDisabled(_tokenId, _isDisabled);\n    }\n\n    function setMinCollateral(uint256 _minCollateral) external onlyOperator(3) {\n        minCollateral = _minCollateral;\n        emit SetMinCollateral(_minCollateral);\n    }\n\n    function setCloseDeltaTime(uint256 _deltaTime) external onlyOperator(2) {\n        require(_deltaTime <= MAX_DELTA_TIME, \"Above max\");\n        closeDeltaTime = _deltaTime;\n        emit SetCloseDeltaTime(_deltaTime);\n    }\n\n    function setMinProfitDuration(uint256 _tokenId, uint256 _minProfitDuration) external onlyOperator(3) {\n        minProfitDurations[_tokenId] = _minProfitDuration;\n        emit SetMinProfitDuration(_tokenId, _minProfitDuration);\n    }\n\n    function setMaxCloseProfit(uint256 _tokenId, uint256 _maxCloseProfit) external onlyOperator(3) {\n        maxCloseProfits[_tokenId] = _maxCloseProfit;\n        emit SetMaxCloseProfit(_tokenId, _maxCloseProfit);\n    }\n\n    function setMaxCloseProfitPercent(uint256 _tokenId, uint256 _maxCloseProfitPercent) external onlyOperator(3) {\n        maxCloseProfitPercents[_tokenId] = _maxCloseProfitPercent;\n        emit SetMaxCloseProfitPercent(_tokenId, _maxCloseProfitPercent);\n    }\n\n    /* VIEW FUNCTIONS */\n    function getPnl(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _size,\n        uint256 _averagePrice,\n        uint256 _lastPrice,\n        uint256 _lastIncreasedTime,\n        uint256 _accruedBorrowFee,\n        int256 _fundingIndex\n    ) external view override returns (int256 pnl, int256 fundingFee, int256 borrowFee) {\n        require(_averagePrice > 0, \"avgPrice > 0\");\n\n        if (_isLong) {\n            if (_lastPrice >= _averagePrice) {\n                pnl = int256((_size * (_lastPrice - _averagePrice)) / _averagePrice);\n            } else {\n                pnl = -1 * int256((_size * (_averagePrice - _lastPrice)) / _averagePrice);\n            }\n        } else {\n            if (_lastPrice <= _averagePrice) {\n                pnl = int256((_size * (_averagePrice - _lastPrice)) / _averagePrice);\n            } else {\n                pnl = -1 * int256((_size * (_lastPrice - _averagePrice)) / _averagePrice);\n            }\n        }\n\n        fundingFee = getFundingFee(_tokenId, _isLong, _size, _fundingIndex);\n        borrowFee = int256(getBorrowFee(_size, _lastIncreasedTime, _tokenId, _isLong) + _accruedBorrowFee);\n\n        pnl = pnl - fundingFee - borrowFee;\n    }\n\n    /* ========== OPEN INTEREST MECHANISM ========== */\n    /* OP FUNCTIONS */\n    function setDefaultMaxOpenInterestPerUser(uint256 _maxAmount) external onlyOperator(1) {\n        defaultMaxOpenInterestPerUser = _maxAmount;\n        emit SetDefaultMaxOpenInterestPerUser(_maxAmount);\n    }\n\n    function setMaxOpenInterestPerUser(address _account, uint256 _maxAmount) external onlyOperator(2) {\n        maxOpenInterestPerUser[_account] = _maxAmount;\n        emit SetMaxOpenInterestPerUser(_account, _maxAmount);\n    }\n\n    function setMaxOpenInterestPerAsset(uint256 _tokenId, uint256 _maxAmount) external override onlyOperator(2) {\n        setMaxOpenInterestPerAssetPerSide(_tokenId, true, _maxAmount);\n        setMaxOpenInterestPerAssetPerSide(_tokenId, false, _maxAmount);\n    }\n\n    function setMaxOpenInterestPerAssetPerSide(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _maxAmount\n    ) public onlyOperator(2) {\n        maxOpenInterestPerAssetPerSide[_tokenId][_isLong] = _maxAmount;\n        emit SetMaxOpenInterestPerAssetPerSide(_tokenId, _isLong, _maxAmount);\n    }\n\n    function setMaxTotalOpenInterest(uint256 _maxAmount) external onlyOperator(2) {\n        maxTotalOpenInterest = _maxAmount;\n        emit SetMaxTotalOpenInterest(_maxAmount);\n    }\n\n    /* VAULT FUNCTIONS */\n    function increaseOpenInterest(\n        uint256 _tokenId,\n        address _sender,\n        bool _isLong,\n        uint256 _amount\n    ) external override onlyVault {\n        // check and increase openInterestPerUser\n        uint256 _openInterestPerUser = openInterestPerUser[_sender];\n        uint256 _maxOpenInterestPerUser = maxOpenInterestPerUser[_sender];\n        if (_maxOpenInterestPerUser == 0) _maxOpenInterestPerUser = defaultMaxOpenInterestPerUser;\n        require(_openInterestPerUser + _amount <= _maxOpenInterestPerUser, \"user maxOI exceeded\");\n        openInterestPerUser[_sender] = _openInterestPerUser + _amount;\n\n        // check and increase openInterestPerAssetPerSide\n        uint256 _openInterestPerAssetPerSide = openInterestPerAssetPerSide[_tokenId][_isLong];\n        require(\n            _openInterestPerAssetPerSide + _amount <= maxOpenInterestPerAssetPerSide[_tokenId][_isLong],\n            \"asset side maxOI exceeded\"\n        );\n        openInterestPerAssetPerSide[_tokenId][_isLong] = _openInterestPerAssetPerSide + _amount;\n\n        // check and increase totalOpenInterest\n        uint256 _totalOpenInterest = totalOpenInterest + _amount;\n        require(_totalOpenInterest <= maxTotalOpenInterest, \"maxTotalOpenInterest exceeded\");\n        totalOpenInterest = _totalOpenInterest;\n\n        emit IncreaseOpenInterest(_tokenId, _isLong, _amount);\n    }\n\n    function decreaseOpenInterest(\n        uint256 _tokenId,\n        address _sender,\n        bool _isLong,\n        uint256 _amount\n    ) external override onlyVault {\n        uint256 _openInterestPerUser = openInterestPerUser[_sender];\n        if (_openInterestPerUser < _amount) {\n            openInterestPerUser[_sender] = 0;\n        } else {\n            openInterestPerUser[_sender] = _openInterestPerUser - _amount;\n        }\n\n        uint256 _openInterestPerAssetPerSide = openInterestPerAssetPerSide[_tokenId][_isLong];\n        if (_openInterestPerAssetPerSide < _amount) {\n            openInterestPerAssetPerSide[_tokenId][_isLong] = 0;\n        } else {\n            openInterestPerAssetPerSide[_tokenId][_isLong] = _openInterestPerAssetPerSide - _amount;\n        }\n\n        uint256 _totalOpenInterest = totalOpenInterest;\n        if (_totalOpenInterest < _amount) {\n            totalOpenInterest = 0;\n        } else {\n            totalOpenInterest = _totalOpenInterest - _amount;\n        }\n\n        emit DecreaseOpenInterest(_tokenId, _isLong, _amount);\n    }\n\n    /* ========== MARKET ORDER ========== */\n    /* OP FUNCTIONS */\n    function setMarketOrderGasFee(uint256 _fee) external onlyOperator(3) {\n        require(_fee <= MAX_MARKET_ORDER_GAS_FEE, \"Above max\");\n        marketOrderGasFee = _fee;\n        emit SetMarketOrderGasFee(_fee);\n    }\n\n    function setExpiryDuration(uint256 _expiryDuration) external onlyOperator(3) {\n        require(_expiryDuration <= MAX_EXPIRY_DURATION, \"Above max\");\n        expiryDuration = _expiryDuration;\n        emit SetExpiryDuration(_expiryDuration);\n    }\n\n    function setSelfExecuteCooldown(uint256 _selfExecuteCooldown) external onlyOperator(3) {\n        require(_selfExecuteCooldown <= MAX_SELF_EXECUTE_COOLDOWN, \"Above max\");\n        selfExecuteCooldown = _selfExecuteCooldown;\n        emit SetSelfExecuteCooldown(_selfExecuteCooldown);\n    }\n\n    /* ========== TRIGGER ORDER ========== */\n    /* OP FUNCTIONS */\n    function setTriggerGasFee(uint256 _fee) external onlyOperator(3) {\n        require(_fee <= MAX_TRIGGER_GAS_FEE, \"Above max\");\n        triggerGasFee = _fee;\n        emit SetTriggerGasFee(_fee);\n    }\n\n    function setMaxTriggerPerPosition(uint256 _value) external onlyOperator(3) {\n        maxTriggerPerPosition = _value;\n        emit SetMaxTriggerPerPosition(_value);\n    }\n\n    function setPriceMovementPercent(uint256 _priceMovementPercent) external onlyOperator(3) {\n        require(_priceMovementPercent <= MAX_PRICE_MOVEMENT_PERCENT, \"Above max\");\n        priceMovementPercent = _priceMovementPercent;\n        emit SetPriceMovementPercent(_priceMovementPercent);\n    }\n\n    /* ========== ARTIFICIAL SLIPPAGE MECHANISM ========== */\n    /* OP FUNCTIONS */\n    function setSlippageFactor(uint256 _tokenId, uint256 _slippageFactor) external onlyOperator(3) {\n        require(_slippageFactor <= BASIS_POINTS_DIVISOR, \"Above max\");\n        slippageFactor[_tokenId] = _slippageFactor;\n        emit SetSlippageFactor(_tokenId, _slippageFactor);\n    }\n\n    /* VIEW FUNCTIONS */\n    function getPriceWithSlippage(\n        uint256 _tokenId,\n        bool _isLong,\n        uint256 _size,\n        uint256 _price\n    ) external view override returns (uint256) {\n        uint256 _slippageFactor = slippageFactor[_tokenId];\n\n        if (_slippageFactor == 0) return _price;\n\n        uint256 slippage = getSlippage(_slippageFactor, _size);\n\n        return\n            _isLong\n                ? (_price * (BASIS_POINTS_DIVISOR + slippage)) / BASIS_POINTS_DIVISOR\n                : (_price * (BASIS_POINTS_DIVISOR - slippage)) / BASIS_POINTS_DIVISOR;\n    }\n\n    function getSlippage(uint256 _slippageFactor, uint256 _size) public view returns (uint256) {\n        return (_slippageFactor * (2 * totalOpenInterest + _size)) / (2 * positionVault.getVaultUSDBalance());\n    }\n\n    /* ========== LIQUIDATE MECHANISM ========== */\n    /* OP FUNCTIONS */\n    // the liquidateThreshold should range between 80% to 100%\n    function setLiquidateThreshold(uint256 _tokenId, uint256 _liquidateThreshold) external onlyOperator(3) {\n        require(\n            _liquidateThreshold >= 8 * BASIS_POINTS_DIVISOR && _liquidateThreshold <= LIQUIDATE_THRESHOLD_DIVISOR,\n            \"Out of range\"\n        );\n        liquidateThreshold[_tokenId] = _liquidateThreshold;\n        emit SetLiquidateThreshold(_tokenId, _liquidateThreshold);\n    }\n\n    function setLiquidationPendingTime(uint256 _liquidationPendingTime) external onlyOperator(3) {\n        require(_liquidationPendingTime <= 60, \"Above max\");\n        liquidationPendingTime = _liquidationPendingTime;\n        emit SetLiquidationPendingTime(_liquidationPendingTime);\n    }\n\n    function setBountyPercent(\n        uint32 _bountyPercentFirstCaller,\n        uint32 _bountyPercentResolver\n    ) external onlyOperator(3) {\n        require(_bountyPercentFirstCaller + _bountyPercentResolver <= BASIS_POINTS_DIVISOR, \"invalid bountyPercent\");\n        bountyPercent_.firstCaller = _bountyPercentFirstCaller;\n        bountyPercent_.resolver = _bountyPercentResolver;\n        emit SetBountyPercent(_bountyPercentFirstCaller, _bountyPercentResolver);\n    }\n\n    /* VIEW FUNCTIONS */\n    function bountyPercent() external view override returns (uint32, uint32) {\n        return (bountyPercent_.firstCaller, bountyPercent_.resolver);\n    }\n\n    /* ========== DELEGATE MECHANISM========== */\n    /* USER FUNCTIONS */\n    function delegate(address[] memory _delegates) external {\n        for (uint256 i = 0; i < _delegates.length; ++i) {\n            EnumerableSetUpgradeable.add(_delegatesByMaster[msg.sender], _delegates[i]);\n        }\n    }\n\n    function undelegate(address[] memory _delegates) external {\n        for (uint256 i = 0; i < _delegates.length; ++i) {\n            EnumerableSetUpgradeable.remove(_delegatesByMaster[msg.sender], _delegates[i]);\n        }\n    }\n\n    /* OP FUNCTIONS */\n    function setGlobalDelegates(address _delegate, bool _allowed) external onlyOperator(2) {\n        globalDelegates[_delegate] = _allowed;\n        emit GlobalDelegatesChange(_delegate, _allowed);\n    }\n\n    /* VIEW FUNCTIONS */\n    function getDelegates(address _master) external view override returns (address[] memory) {\n        return enumerate(_delegatesByMaster[_master]);\n    }\n\n    function checkDelegation(address _master, address _delegate) public view override returns (bool) {\n        require(!checkBanList(_master), \"account banned\");\n        return\n            _master == _delegate ||\n            globalDelegates[_delegate] ||\n            EnumerableSetUpgradeable.contains(_delegatesByMaster[_master], _delegate);\n    }\n\n    /* ========== BAN MECHANISM========== */\n    /* OP FUNCTIONS */\n    function addWalletsToBanList(address[] memory _wallets) external onlyOperator(1) {\n        for (uint256 i = 0; i < _wallets.length; ++i) {\n            EnumerableSetUpgradeable.add(banWalletList, _wallets[i]);\n        }\n    }\n\n    function removeWalletsFromBanList(address[] memory _wallets) external onlyOperator(1) {\n        for (uint256 i = 0; i < _wallets.length; ++i) {\n            EnumerableSetUpgradeable.remove(banWalletList, _wallets[i]);\n        }\n    }\n\n    /* VIEW FUNCTIONS */\n    function checkBanList(address _addr) public view override returns (bool) {\n        return EnumerableSetUpgradeable.contains(banWalletList, _addr);\n    }\n\n    function enumerate(EnumerableSetUpgradeable.AddressSet storage set) internal view returns (address[] memory) {\n        uint256 length = EnumerableSetUpgradeable.length(set);\n        address[] memory output = new address[](length);\n        for (uint256 i; i < length; ++i) {\n            output[i] = EnumerableSetUpgradeable.at(set, i);\n        }\n        return output;\n    }\n}"
    },
    "contracts/core/structs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nenum OrderType {\n    MARKET,\n    LIMIT,\n    STOP,\n    STOP_LIMIT\n}\n\nenum OrderStatus {\n    NONE,\n    PENDING,\n    FILLED,\n    CANCELED\n}\n\nenum TriggerStatus {\n    NONE,\n    PENDING,\n    OPEN,\n    TRIGGERED,\n    CANCELLED\n}\n\nstruct Order {\n    OrderStatus status;\n    uint256 lmtPrice;\n    uint256 size;\n    uint256 collateral;\n    uint256 positionType;\n    uint256 stepAmount;\n    uint256 stepType;\n    uint256 stpPrice;\n    uint256 timestamp;\n}\n\nstruct AddPositionOrder {\n    address owner;\n    uint256 collateral;\n    uint256 size;\n    uint256 allowedPrice;\n    uint256 timestamp;\n    uint256 fee;\n}\n\nstruct DecreasePositionOrder {\n    uint256 size;\n    uint256 allowedPrice;\n    uint256 timestamp;\n}\n\nstruct Position {\n    address owner;\n    address refer;\n    bool isLong;\n    uint256 tokenId;\n    uint256 averagePrice;\n    uint256 collateral;\n    int256 fundingIndex;\n    uint256 lastIncreasedTime;\n    uint256 size;\n    uint256 accruedBorrowFee;\n}\n\nstruct PaidFees {\n    uint256 paidPositionFee;\n    uint256 paidBorrowFee;\n    int256 paidFundingFee;\n}\n\nstruct Temp {\n    uint256 a;\n    uint256 b;\n    uint256 c;\n    uint256 d;\n    uint256 e;\n}\n\nstruct TriggerInfo {\n    bool isTP;\n    uint256 amountPercent;\n    uint256 createdAt;\n    uint256 price;\n    uint256 triggeredAmount;\n    uint256 triggeredAt;\n    TriggerStatus status;\n}\n\nstruct PositionTrigger {\n    TriggerInfo[] triggers;\n}"
    },
    "contracts/core/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\nimport \"../tokens/interfaces/IVUSD.sol\";\nimport \"./interfaces/IPositionVault.sol\";\nimport \"./interfaces/ILiquidateVault.sol\";\nimport \"./interfaces/IOrderVault.sol\";\nimport \"./interfaces/IPriceManager.sol\";\nimport \"./interfaces/ISettingsManager.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IOperators.sol\";\nimport {Constants} from \"../access/Constants.sol\";\nimport {Position, OrderStatus, OrderType} from \"./structs.sol\";\n\ncontract Vault is Constants, Initializable, ReentrancyGuardUpgradeable, IVault {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // constants\n    IPositionVault private positionVault;\n    IOrderVault private orderVault;\n    ILiquidateVault private liquidateVault;\n    IOperators public operators;\n    IPriceManager private priceManager;\n    ISettingsManager private settingsManager;\n    address private vlp;\n    address private vusd;\n    bool private isInitialized;\n\n    // variables\n    uint256 public totalUSD;\n    mapping(address => uint256) public override lastStakedAt;\n    IERC20Upgradeable private USDC;\n    mapping(address => uint256) public lastStakedBlockAt;\n    mapping(address => address) public platformUsed; // trader address => address of platform used\n\n    event Deposit(address indexed account, address indexed token, uint256 amount);\n    event Withdraw(address indexed account, address indexed token, uint256 amount);\n    event Stake(address indexed account, address token, uint256 amount, uint256 mintAmount);\n    event Unstake(address indexed account, address token, uint256 vlpAmount, uint256 amountOut);\n    event ForceClose(uint256 indexed posId, address indexed account, uint256 exceededPnl);\n    event ReferFeeTransfer(address indexed account, uint256 amount);\n    event ReferFeeTraderRebate(address indexed account, uint256 amount, address indexed trader, uint256 rebate);\n    event PlatformFeeTransfer(address indexed account, uint256 amount, address indexed trader);\n\n    modifier onlyVault() {\n        _onlyVault();\n        _;\n    }\n\n    function _onlyVault() private view {\n        require(\n            msg.sender == address(positionVault) ||\n                msg.sender == address(liquidateVault) ||\n                msg.sender == address(orderVault),\n            \"Only vault\"\n        );\n    }\n\n    modifier preventBanners(address _account) {\n        _preventBanners(_account);\n        _;\n    }\n\n    function _preventBanners(address _account) private view {\n        require(!settingsManager.checkBanList(_account), \"Account banned\");\n    }\n\n    modifier onlyOperator(uint256 level) {\n        _onlyOperator(level);\n        _;\n    }\n\n    function _onlyOperator(uint256 level) private view {\n        require(operators.getOperatorLevel(msg.sender) >= level, \"invalid operator\");\n    }\n\n    /* ========== INITIALIZE FUNCTIONS ========== */\n\n    function initialize(address _operators, address _vlp, address _vusd) public initializer {\n        require(AddressUpgradeable.isContract(_operators), \"operators invalid\");\n\n        __ReentrancyGuard_init();\n        operators = IOperators(_operators);\n        vlp = _vlp;\n        vusd = _vusd;\n    }\n\n    function setVaultSettings(\n        IPriceManager _priceManager,\n        ISettingsManager _settingsManager,\n        IPositionVault _positionVault,\n        IOrderVault _orderVault,\n        ILiquidateVault _liquidateVault\n    ) external onlyOperator(4) {\n        require(!isInitialized, \"initialized\");\n        require(AddressUpgradeable.isContract(address(_priceManager)), \"priceManager invalid\");\n        require(AddressUpgradeable.isContract(address(_settingsManager)), \"settingsManager invalid\");\n        require(AddressUpgradeable.isContract(address(_positionVault)), \"positionVault invalid\");\n        require(AddressUpgradeable.isContract(address(_orderVault)), \"orderVault invalid\");\n        require(AddressUpgradeable.isContract(address(_liquidateVault)), \"liquidateVault invalid\");\n\n        priceManager = _priceManager;\n        settingsManager = _settingsManager;\n        positionVault = _positionVault;\n        orderVault = _orderVault;\n        liquidateVault = _liquidateVault;\n        isInitialized = true;\n    }\n\n    function setUSDC(IERC20Upgradeable _token) external onlyOperator(3) {\n        USDC = _token;\n    }\n\n    /* ========== CORE FUNCTIONS ========== */\n\n    // deposit stablecoin to mint vusd\n    function deposit(address _account, address _token, uint256 _amount) public nonReentrant preventBanners(msg.sender) {\n        require(settingsManager.isDeposit(_token), \"deposit not allowed\");\n        require(_amount > 0, \"zero amount\");\n        if (_account != msg.sender) {\n            require(settingsManager.checkDelegation(_account, msg.sender), \"Not allowed\");\n        }\n\n        IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 usdAmount = priceManager.tokenToUsd(_token, _amount);\n        uint256 depositFee = (usdAmount * settingsManager.depositFee(_token)) / BASIS_POINTS_DIVISOR;\n        _distributeFee(depositFee, address(0), address(0));\n\n        IVUSD(vusd).mint(_account, usdAmount - depositFee);\n\n        emit Deposit(_account, _token, _amount);\n    }\n\n    function depositSelf(address _token, uint256 _amount) external {\n        deposit(msg.sender, _token, _amount);\n    }\n\n    function depositSelfUSDC(uint256 _amount) external {\n        deposit(msg.sender, address(USDC), _amount);\n    }\n\n    function depositSelfAllUSDC() external {\n        deposit(msg.sender, address(USDC), USDC.balanceOf(msg.sender));\n    }\n\n    // burn vusd to withdraw stablecoin\n    function withdraw(address _token, uint256 _amount) public nonReentrant preventBanners(msg.sender) {\n        require(settingsManager.isWithdraw(_token), \"withdraw not allowed\");\n        require(_amount > 0, \"zero amount\");\n\n        IVUSD(vusd).burn(address(msg.sender), _amount);\n\n        uint256 withdrawFee = (_amount * settingsManager.withdrawFee(_token)) / BASIS_POINTS_DIVISOR;\n        _distributeFee(withdrawFee, address(0), address(0));\n\n        uint256 tokenAmount = priceManager.usdToToken(_token, _amount - withdrawFee);\n        IERC20Upgradeable(_token).safeTransfer(msg.sender, tokenAmount);\n\n        emit Withdraw(address(msg.sender), _token, tokenAmount);\n    }\n\n    function withdrawUSDC(uint256 _amount) external {\n        withdraw(address(USDC), _amount);\n    }\n\n    function withdrawAllUSDC() external {\n        withdraw(address(USDC), IVUSD(vusd).balanceOf(msg.sender));\n    }\n\n    // stake stablecoin to mint vlp\n    function stake(address _account, address _token, uint256 _amount) public nonReentrant preventBanners(msg.sender) {\n        require(settingsManager.isStakingEnabled(_token), \"staking disabled\");\n        require(_amount > 0, \"zero amount\");\n        if (_account != msg.sender) require(settingsManager.checkDelegation(_account, msg.sender), \"Not allowed\");\n\n        IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 usdAmount = priceManager.tokenToUsd(_token, _amount);\n        uint256 stakingFee = (usdAmount * settingsManager.stakingFee(_token)) / BASIS_POINTS_DIVISOR;\n        uint256 usdAmountAfterFee = usdAmount - stakingFee;\n\n        uint256 mintAmount;\n        uint256 totalVLP = IERC20Upgradeable(vlp).totalSupply();\n        if (totalVLP == 0) {\n            mintAmount =\n                (usdAmountAfterFee * DEFAULT_VLP_PRICE * (10 ** VLP_DECIMALS)) /\n                (PRICE_PRECISION * BASIS_POINTS_DIVISOR);\n        } else {\n            mintAmount = (usdAmountAfterFee * totalVLP) / totalUSD;\n        }\n\n        require(totalVLP + mintAmount <= settingsManager.maxTotalVlp(), \"max total vlp exceeded\");\n\n        _distributeFee(stakingFee, address(0), address(0));\n\n        totalUSD += usdAmountAfterFee;\n        lastStakedAt[_account] = block.timestamp;\n        IMintable(vlp).mint(_account, mintAmount);\n\n        emit Stake(_account, _token, _amount, mintAmount);\n    }\n\n    function stakeSelf(address _token, uint256 _amount) external {\n        stake(msg.sender, _token, _amount);\n    }\n\n    function stakeSelfUSDC(uint256 _amount) external {\n        stake(msg.sender, address(USDC), _amount);\n    }\n\n    function stakeSelfAllUSDC() external {\n        stake(msg.sender, address(USDC), USDC.balanceOf(msg.sender));\n    }\n\n    // burn vlp to unstake stablecoin\n    // vlp cannot be unstaked or transferred within cooldown period, except whitelisted contracts\n    function unstake(address _tokenOut, uint256 _vlpAmount) public nonReentrant preventBanners(msg.sender) {\n        require(settingsManager.isUnstakingEnabled(_tokenOut), \"unstaking disabled\");\n        uint256 totalVLP = IERC20Upgradeable(vlp).totalSupply();\n        require(_vlpAmount > 0 && _vlpAmount <= totalVLP, \"vlpAmount error\");\n        if (settingsManager.isWhitelistedFromCooldown(msg.sender) == false) {\n            require(\n                lastStakedAt[msg.sender] + settingsManager.cooldownDuration() <= block.timestamp,\n                \"cooldown duration not yet passed\"\n            );\n        }\n\n        IMintable(vlp).burn(msg.sender, _vlpAmount);\n\n        uint256 usdAmount = (_vlpAmount * totalUSD) / totalVLP;\n        uint256 unstakingFee = (usdAmount * settingsManager.unstakingFee(_tokenOut)) / BASIS_POINTS_DIVISOR;\n\n        _distributeFee(unstakingFee, address(0), address(0));\n\n        totalUSD -= usdAmount;\n        uint256 tokenAmountOut = priceManager.usdToToken(_tokenOut, usdAmount - unstakingFee);\n        IERC20Upgradeable(_tokenOut).safeTransfer(msg.sender, tokenAmountOut);\n\n        emit Unstake(msg.sender, _tokenOut, _vlpAmount, tokenAmountOut);\n    }\n\n    function unstakeUSDC(uint256 _vlpAmount) external {\n        unstake(address(USDC), _vlpAmount);\n    }\n\n    function unstakeAllUSDC() external {\n        unstake(address(USDC), IERC20Upgradeable(vlp).balanceOf(msg.sender));\n    }\n\n    // submit order to create a new position\n    function newPositionOrder(\n        uint256 _tokenId,\n        bool _isLong,\n        OrderType _orderType,\n        // 0 -> market order\n        // 1 -> limit order\n        // 2 -> stop-market order\n        // 3 -> stop-limit order\n        uint256[] memory _params,\n        // for market order:  _params[0] -> allowed price (revert if exceeded)\n        // for limit order: _params[0] -> limit price\n        // In stop-market order: _params[1] -> stop price,\n        // In stop-limit order: _params[0] -> limit price, _params[1] -> stop price\n        // for all orders: _params[2] -> collateral\n        // for all orders: _params[3] -> size\n        address _refer\n    ) public payable nonReentrant preventBanners(msg.sender) {\n        if (_orderType == OrderType.MARKET) {\n            require(msg.value == settingsManager.marketOrderGasFee(), \"invalid marketOrderGasFee\");\n        } else {\n            require(msg.value == settingsManager.triggerGasFee(), \"invalid triggerGasFee\");\n        }\n        (bool success, ) = payable(settingsManager.feeManager()).call{value: msg.value}(\"\");\n        require(success, \"failed to send fee\");\n        require(_refer != msg.sender, \"Refer error\");\n        positionVault.newPositionOrder(msg.sender, _tokenId, _isLong, _orderType, _params, _refer);\n    }\n\n    function newPositionOrderPacked(uint256 a, uint256 b, uint256 c) external payable {\n        uint256 tokenId = a / 2 ** 240; //16 bits for tokenId\n        uint256 tmp = (a % 2 ** 240) / 2 ** 232;\n        bool isLong = tmp / 2 ** 7 == 1; // 1 bit for isLong\n        OrderType orderType = OrderType(tmp % 2 ** 7); // 7 bits for orderType\n        address refer = address(uint160(a)); //last 160 bit for refer\n        uint256[] memory params = new uint256[](4);\n        params[0] = b / 2 ** 128; //price\n        params[1] = b % 2 ** 128; //price\n        params[2] = c / 2 ** 128; //collateral\n        params[3] = c % 2 ** 128; //size\n        newPositionOrder(tokenId, isLong, orderType, params, refer);\n    }\n\n    // submit order to create a new position with take profit / stop loss orders\n    function newPositionOrderWithTPSL(\n        uint256 _tokenId,\n        bool _isLong,\n        OrderType _orderType,\n        // 0 -> market order\n        // 1 -> limit order\n        // 2 -> stop-market order\n        // 3 -> stop-limit order\n        uint256[] memory _params,\n        // for market order:  _params[0] -> allowed price (revert if exceeded)\n        // for limit order: _params[0] -> limit price\n        // In stop-market order: _params[1] -> stop price,\n        // In stop-limit order: _params[0] -> limit price, _params[1] -> stop price\n        // for all orders: _params[2] -> collateral\n        // for all orders: _params[3] -> size\n        address _refer,\n        bool[] memory _isTPs,\n        uint256[] memory _prices,\n        uint256[] memory _amountPercents\n    ) external payable nonReentrant preventBanners(msg.sender) {\n        if (_orderType == OrderType.MARKET) {\n            require(\n                msg.value == settingsManager.marketOrderGasFee() + _prices.length * settingsManager.triggerGasFee(),\n                \"invalid marketOrderGasFee\"\n            );\n        } else {\n            require(msg.value == (_prices.length + 1) * settingsManager.triggerGasFee(), \"invalid triggerGasFee\");\n        }\n        (bool success, ) = payable(settingsManager.feeManager()).call{value: msg.value}(\"\");\n        require(success, \"failed to send fee\");\n        require(_refer != msg.sender, \"Refer error\");\n        positionVault.newPositionOrder(msg.sender, _tokenId, _isLong, _orderType, _params, _refer);\n        orderVault.addTriggerOrders(positionVault.lastPosId() - 1, msg.sender, _isTPs, _prices, _amountPercents);\n    }\n\n    // submit market order to increase size of exisiting position\n    function addPosition(\n        uint256 _posId,\n        uint256 _collateralDelta,\n        uint256 _sizeDelta,\n        uint256 _allowedPrice\n    ) public payable nonReentrant preventBanners(msg.sender) {\n        require(msg.value == settingsManager.marketOrderGasFee(), \"invalid triggerGasFee\");\n        (bool success, ) = payable(settingsManager.feeManager()).call{value: msg.value}(\"\");\n        require(success, \"failed to send fee\");\n\n        positionVault.createAddPositionOrder(msg.sender, _posId, _collateralDelta, _sizeDelta, _allowedPrice);\n    }\n\n    function addPositionPacked(uint256 a, uint256 b) external payable {\n        uint256 posId = a / 2 ** 128;\n        uint256 collateralDelta = a % 2 ** 128;\n        uint256 sizeDelta = b / 2 ** 128;\n        uint256 allowedPrice = b % 2 ** 128;\n        addPosition(posId, collateralDelta, sizeDelta, allowedPrice);\n    }\n\n    // add collateral to reduce leverage\n    function addCollateral(uint256 _posId, uint256 _amount) public nonReentrant preventBanners(msg.sender) {\n        positionVault.addOrRemoveCollateral(msg.sender, _posId, true, _amount);\n    }\n\n    // remove collateral to increase leverage\n    function removeCollateral(uint256 _posId, uint256 _amount) public payable nonReentrant preventBanners(msg.sender) {\n        require(msg.value == settingsManager.marketOrderGasFee(), \"invalid triggerGasFee\");\n        (bool success, ) = payable(settingsManager.feeManager()).call{value: msg.value}(\"\");\n        require(success, \"failed to send fee\");\n\n        positionVault.addOrRemoveCollateral(msg.sender, _posId, false, _amount);\n    }\n\n    function addOrRemoveCollateralPacked(uint256 a) external {\n        uint256 posId = a >> 128;\n        bool isPlus = (a >> 127) % 2 == 1;\n        uint256 amount = a % 2 ** 127;\n        if (isPlus) {\n            return addCollateral(posId, amount);\n        } else {\n            return removeCollateral(posId, amount);\n        }\n    }\n\n    // submit market order to decrease size of exisiting position\n    function decreasePosition(\n        uint256 _sizeDelta,\n        uint256 _allowedPrice,\n        uint256 _posId\n    ) public payable nonReentrant preventBanners(msg.sender) {\n        require(msg.value == settingsManager.marketOrderGasFee(), \"invalid marketOrderGasFee\");\n        (bool success, ) = payable(settingsManager.feeManager()).call{value: msg.value}(\"\");\n        require(success, \"failed to send fee\");\n\n        positionVault.createDecreasePositionOrder(_posId, msg.sender, _sizeDelta, _allowedPrice);\n    }\n\n    function decreasePositionPacked(uint256 a, uint256 _posId) external payable {\n        uint256 sizeDelta = a / 2 ** 128;\n        uint256 allowedPrice = a % 2 ** 128;\n        return decreasePosition(sizeDelta, allowedPrice, _posId);\n    }\n\n    function addTPSL(\n        uint256 _posId,\n        bool[] memory _isTPs,\n        uint256[] memory _prices,\n        uint256[] memory _amountPercents\n    ) public payable nonReentrant preventBanners(msg.sender) {\n        require(msg.value == settingsManager.triggerGasFee() * _prices.length, \"invalid triggerGasFee\");\n        (bool success, ) = payable(settingsManager.feeManager()).call{value: msg.value}(\"\");\n        require(success, \"failed to send fee\");\n\n        orderVault.addTriggerOrders(_posId, msg.sender, _isTPs, _prices, _amountPercents);\n    }\n\n    function addTPSLPacked(uint256 a, uint256[] calldata _tps) external payable {\n        uint256 posId = a / 2 ** 128;\n        uint256 length = _tps.length;\n        bool[] memory isTPs = new bool[](length);\n        uint256[] memory prices = new uint256[](length);\n        uint256[] memory amountPercents = new uint256[](length);\n        for (uint i; i < length; ++i) {\n            prices[i] = _tps[i] / 2 ** 128;\n            isTPs[i] = (_tps[i] / 2 ** 127) % 2 == 1;\n            amountPercents[i] = _tps[i] % 2 ** 127;\n        }\n        addTPSL(posId, isTPs, prices, amountPercents);\n    }\n\n    // submit trailing stop order to decrease size of exisiting position\n    function addTrailingStop(\n        uint256 _posId,\n        uint256[] memory _params\n    ) external payable nonReentrant preventBanners(msg.sender) {\n        require(msg.value == settingsManager.triggerGasFee(), \"invalid triggerGasFee\");\n        (bool success, ) = payable(settingsManager.feeManager()).call{value: msg.value}(\"\");\n        require(success, \"failed to send fee\");\n\n        orderVault.addTrailingStop(msg.sender, _posId, _params);\n    }\n\n    // cancel pending newPositionOrder / trailingStopOrder\n    function cancelPendingOrder(uint256 _posId) public nonReentrant preventBanners(msg.sender) {\n        orderVault.cancelPendingOrder(msg.sender, _posId);\n    }\n\n    // cancel multiple pending newPositionOrder / trailingStopOrder\n    function cancelPendingOrders(uint256[] memory _posIds) external preventBanners(msg.sender) {\n        for (uint i = 0; i < _posIds.length; ++i) {\n            orderVault.cancelPendingOrder(msg.sender, _posIds[i]);\n        }\n    }\n\n    function setPlatformUsed(address _platform) external {\n        platformUsed[msg.sender] = _platform;\n    }\n\n    /* ========== HELPER FUNCTIONS ========== */\n\n    // account trader's profit / loss into vault\n    function accountDeltaIntoTotalUSD(bool _isIncrease, uint256 _delta) external override onlyVault {\n        if (_delta > 0) {\n            if (_isIncrease) {\n                totalUSD += _delta;\n            } else {\n                require(totalUSD >= _delta, \"exceeded VLP bottom\");\n                totalUSD -= _delta;\n            }\n        }\n    }\n\n    function distributeFee(uint256 _fee, address _refer, address _trader) external override onlyVault {\n        _distributeFee(_fee, _refer, _trader);\n    }\n\n    // to distribute fee among referrer, vault and feeManager\n    function _distributeFee(uint256 _fee, address _refer, address _trader) internal {\n        if (_fee > 0) {\n            if (_refer != address(0)) {\n                (uint256 referFee, uint256 traderRebate) = settingsManager.getReferFeeAndTraderRebate(_refer);\n                referFee = (_fee * referFee) / BASIS_POINTS_DIVISOR;\n                traderRebate = (_fee * traderRebate) / BASIS_POINTS_DIVISOR;\n\n                IVUSD(vusd).mint(_refer, referFee);\n                if (traderRebate > 0) IVUSD(vusd).mint(_trader, traderRebate);\n\n                _fee -= referFee + traderRebate;\n                emit ReferFeeTraderRebate(_refer, referFee, _trader, traderRebate);\n            }\n\n            if (_trader != address(0)) {\n                address platform = platformUsed[_trader];\n                uint256 platformFee = settingsManager.platformFees(platform);\n                if (platformFee > 0) {\n                    platformFee = (_fee * platformFee) / BASIS_POINTS_DIVISOR;\n\n                    IVUSD(vusd).mint(platform, platformFee);\n\n                    _fee -= platformFee;\n                    emit PlatformFeeTransfer(platform, platformFee, _trader);\n                }\n            }\n\n            uint256 feeForVLP = (_fee * settingsManager.feeRewardBasisPoints()) / BASIS_POINTS_DIVISOR;\n            totalUSD += feeForVLP;\n            IVUSD(vusd).mint(settingsManager.feeManager(), _fee - feeForVLP);\n        }\n    }\n\n    function takeVUSDIn(address _account, uint256 _amount) external override onlyVault {\n        IVUSD(vusd).burn(_account, _amount);\n    }\n\n    function takeVUSDOut(address _account, uint256 _amount) external override onlyVault {\n        IVUSD(vusd).mint(_account, _amount);\n    }\n\n    /* ========== OPERATOR FUNCTIONS ========== */\n\n    // allow admin to force close a user's position if the position profit > max profit % of totalUSD\n    function forceClosePosition(uint256 _posId) external payable nonReentrant onlyOperator(1) {\n        Position memory position = positionVault.getPosition(_posId);\n        uint256 price = priceManager.getLastPrice(position.tokenId);\n        (int256 pnl, , ) = settingsManager.getPnl(\n            position.tokenId,\n            position.isLong,\n            position.size,\n            position.averagePrice,\n            price,\n            position.lastIncreasedTime,\n            position.accruedBorrowFee,\n            position.fundingIndex\n        );\n        uint256 _maxProfitPercent = settingsManager.maxProfitPercent(position.tokenId) == 0\n            ? settingsManager.defaultMaxProfitPercent()\n            : settingsManager.maxProfitPercent(position.tokenId);\n        uint256 maxPnl = (totalUSD * _maxProfitPercent) / BASIS_POINTS_DIVISOR;\n        require(pnl > int256(maxPnl), \"not allowed\");\n        positionVault.decreasePosition(_posId, price, position.size);\n        uint256 exceededPnl = uint256(pnl) - maxPnl;\n        IVUSD(vusd).burn(position.owner, exceededPnl); // cap user's pnl to maxPnl\n        totalUSD += exceededPnl; // send pnl back to vault\n        emit ForceClose(_posId, position.owner, exceededPnl);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function getVLPPrice() external view returns (uint256) {\n        uint256 totalVLP = IERC20Upgradeable(vlp).totalSupply();\n        if (totalVLP == 0) {\n            return DEFAULT_VLP_PRICE;\n        } else {\n            return (BASIS_POINTS_DIVISOR * (10 ** VLP_DECIMALS) * totalUSD) / (totalVLP * PRICE_PRECISION);\n        }\n    }\n\n    function getVaultUSDBalance() external view override returns (uint256) {\n        return totalUSD;\n    }\n}"
    },
    "contracts/oracle/FastPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\nuint256 constant BASIS_POINTS_DIVISOR = 100000;\nuint256 constant PRICE_BASE = 10**8;\n\n// Might no longer be used and they just call Pyth directly in the PriceManager\ncontract FastPriceFeed is IPriceFeed {\n    IPyth pyth;\n    address public gov;\n    mapping(address=>uint256) public ts;\n    mapping(address=>uint256) public answer;\n    string public override description = \"FastPriceFeed\";\n    uint256 public decimals;\n    mapping(address=>uint80) public roundId;\n\n    mapping(address=>mapping(uint80 => uint256)) public answers;\n    mapping(address=>mapping(uint80 => uint256)) public latestAts;\n    mapping(address => bool) public isAdmin;\n    mapping(address => bytes32) public priceIds;\n    mapping(address => uint256) public allowedDeviation;\n    mapping(address => uint256) public allowedStaleness;\n\n    event SetAdmin(address indexed account, bool isAdmin);\n    event SetDecription(string description);\n    event SetAnswer(address token, uint256 ts, uint256 answer);\n\n    constructor() {\n        gov = msg.sender;\n        isAdmin[msg.sender] = true;\n    }\n\n    function setPyth(IPyth _pyth) external{\n        require(msg.sender == gov, \"PriceFeed: forbidden\");\n        pyth = _pyth;\n    }\n\n    function setAdmin(address _account, bool _isAdmin) external {\n        require(msg.sender == gov, \"PriceFeed: forbidden\");\n        isAdmin[_account] = _isAdmin;\n        emit SetAdmin(_account, _isAdmin);\n    }\n\n    function setToken(address _token, bytes32 _priceId, uint256 _allowedDeviation, uint256 _allowedStaleness) external {\n        require(msg.sender == gov, \"PriceFeed: forbidden\");\n        require(_allowedDeviation < BASIS_POINTS_DIVISOR, \"invalid _allowedDeviation\");\n        priceIds[_token] = _priceId;\n        allowedDeviation[_token] = _allowedDeviation;\n        allowedStaleness[_token] = _allowedStaleness;\n    }\n\n    function setDescription(string memory _description) external {\n        require(isAdmin[msg.sender], \"PriceFeed: forbidden\");\n        description = _description;\n        emit SetDecription(_description);\n    }\n\n    function getPythLastPrice(address _token, bool _requireFreshness) public view returns (uint256) {\n        PythStructs.Price memory priceInfo = pyth.getPriceUnsafe(priceIds[_token]);\n        if(_requireFreshness){\n            require(block.timestamp <= priceInfo.publishTime + allowedStaleness[_token], \"price stale\");\n        }\n        uint256 price = uint256(uint64(priceInfo.price));\n        if (priceInfo.expo >= 0) {\n            uint256 exponent = uint256(uint32(priceInfo.expo));\n            return price * PRICE_BASE * (10 ** exponent);\n        } else {\n            uint256 exponent = uint256(uint32(-priceInfo.expo));\n            return price * PRICE_BASE / (10 ** exponent);\n        }\n    }\n\n    function setAnswer(address _token, uint256 _ts, uint256 _answer) public override {\n        require(isAdmin[msg.sender], \"PriceFeed: forbidden\");\n        if(_ts < ts[_token]) {\n            return; //other tx have already updated, simply return\n        }\n        if(priceIds[_token] != bytes32(0)){\n            uint256 priceOnChain = getPythLastPrice(_token, false);\n            uint256 diff;\n            if(_answer > priceOnChain){\n                diff = _answer - priceOnChain;\n            }else{\n                diff = priceOnChain - _answer;\n            }\n            uint256 ratio = diff * BASIS_POINTS_DIVISOR / priceOnChain;\n            require(ratio <= allowedDeviation[_token], \"need update pyth price\");\n        }\n        uint80 r = ++roundId[_token];\n        answer[_token] = _answer;\n        ts[_token] = _ts;\n        answers[_token][r] = _answer;\n        latestAts[_token][r] = _ts;\n        emit SetAnswer(_token, _ts, _answer);\n        \n    }\n\n    function setLatestAnswer(address _token, uint256 _answer) external {\n        setAnswer(_token, block.timestamp, _answer);\n    }\n\n    function latestAnswer(address _token) external view override returns (uint256) {\n        if (allowedStaleness[_token] == 0){ \n            // same as before, no check staleness\n            return answer[_token];\n        }\n        uint256 timeDiff = block.timestamp - ts[_token];\n        if (timeDiff <= allowedStaleness[_token]) { \n            // our price is fresh enough, return our answer\n            return answer[_token];\n        } else{\n            // our price is stale, try use on-chain price with freshness requirement\n            return getPythLastPrice(_token, true);\n        }\n    }\n\n    function latestRound(address _token) external view override returns (uint80) {\n        return roundId[_token];\n    }\n\n    // returns roundId, answer, startedAt, updatedAt, answeredInRound\n    function getRoundData(address _token, uint80 _roundId) external view override returns (uint80, uint256, uint256, uint256, uint80) {\n        return (_roundId, answers[_token][_roundId], latestAts[_token][_roundId], 0, 0);\n    }\n}\n"
    },
    "contracts/oracle/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IPriceFeed {\n    function description() external view returns (string memory);\n\n    function getRoundData(address token, uint80 roundId) external view returns (uint80, uint256, uint256, uint256, uint80);\n\n    function latestAnswer(address token) external view returns (uint256);\n\n    function latestRound(address token) external view returns (uint80);\n\n    function setAnswer(address token, uint256 _ts, uint256 _answer) external;\n}\n"
    },
    "contracts/oracle/MockPyth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\ncontract MockPyth{\n    mapping(bytes32=>PythStructs.Price) priceData;\n    /*\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n    */\n    function setPrice(bytes32 _priceId, int64 _price, int32 _expo, uint _publishTime) external{\n        priceData[_priceId] = PythStructs.Price({\n            price: _price,\n            conf: 0, // we do not use this\n            expo: _expo,\n            publishTime: _publishTime\n        });\n    }\n\n    function getPriceUnsafe(bytes32 _priceId) external view returns (PythStructs.Price memory){\n        return priceData[_priceId];\n    }\n\n    function getCurrentTime() external view returns (uint256) {\n        return block.timestamp;\n    }\n}"
    },
    "contracts/staking/ComplexRewardPerSec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/IComplexRewarder.sol\";\nimport \"./interfaces/IFarmDistributor.sol\";\nimport \"../core/interfaces/IOperators.sol\";\nimport \"./libraries/BoringERC20.sol\";\n\ncontract ComplexRewarderPerSec is IComplexRewarder, Initializable, ReentrancyGuardUpgradeable {\n    using BoringERC20 for IBoringERC20;\n\n    IBoringERC20 public override rewardToken;\n    IFarmDistributor public distributor;\n    IOperators public operators;\n\n    struct UserInfo {\n        uint256 amount; /// `amount` LP token amount the user has provided.\n        uint256 rewardDebt; /// `rewardDebt` The amount of REWARD entitled to the user.\n    }\n\n    struct PoolInfo {\n        uint256 accTokenPerShare; /// `accTokenPerShare` Amount of REWARD each LP token is worth.\n        uint256 startTimestamp; /// `startTimestamp` The start timestamp of rewards.\n        uint256 lastRewardTimestamp; /// `lastRewardTimestamp` The last timestamp REWARD was rewarded to the poolInfo.\n        uint256 totalRewards; /// `totalRewards` The amount of rewards added to the pool.\n    }\n\n    struct RewardInfo {\n        uint256 startTimestamp; /// `startTimestamp` The start timestamp of rewards\n        uint256 endTimestamp; /// `endTimestamp` The end timestamp of rewards\n        uint256 rewardPerSec; /// `rewardPerSec` The amount of rewards per second\n    }\n\n    uint256[] public poolIds;\n    uint256 public rewardInfoLimit;\n    uint256 private ACC_TOKEN_PRECISION; // The precision factor\n\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    mapping(uint256 => PoolInfo) public poolInfo;\n    mapping(uint256 => RewardInfo[]) public poolRewardInfo;\n\n    event AddPool(uint256 indexed pid);\n    event AddRewardInfo(uint256 indexed pid, uint256 indexed phase, uint256 endTimestamp, uint256 rewardPerSec);\n    event OnReward(address indexed user, uint256 amount);\n    event RewardRateUpdated(uint256 oldRate, uint256 newRate);\n    event UpdatePool(uint256 indexed pid, uint256 lastRewardTimestamp, uint256 lpSupply, uint256 accTokenPerShare);\n\n    modifier onlyDistributor() {\n        require(msg.sender == address(distributor), \"onlyDistributor: only Distributor can call this function\");\n        _;\n    }\n\n    modifier onlyOperator(uint256 level) {\n        require(operators.getOperatorLevel(msg.sender) >= level, \"invalid operator\");\n        _;\n    }\n\n    function initialize(\n        IBoringERC20 _rewardToken,\n        IFarmDistributor _distributor,\n        address _operators\n    ) public initializer {\n        __ReentrancyGuard_init();\n        require(\n            AddressUpgradeable.isContract(address(_rewardToken)),\n            \"constructor: reward token must be a valid contract\"\n        );\n        require(\n            AddressUpgradeable.isContract(address(_distributor)),\n            \"constructor: FarmDistributor must be a valid contract\"\n        );\n        require(AddressUpgradeable.isContract(_operators), \"operators invalid\");\n        operators = IOperators(_operators);\n        rewardToken = _rewardToken;\n        distributor = _distributor;\n\n        uint256 decimalsRewardToken = _rewardToken.safeDecimals();\n        require(decimalsRewardToken < 30, \"constructor: reward token decimals must be inferior to 30\");\n\n        ACC_TOKEN_PRECISION = uint256(10 ** (uint256(30) - (decimalsRewardToken)));\n        rewardInfoLimit = 52; //1y /// how many phases are allowed\n    }\n\n    /// @notice Add a new pool. Can only be called by the operator.\n    /// @param _pid pool id on DistributorV2\n    function add(uint256 _pid, uint256 _startTimestamp) public onlyOperator(1) {\n        require(poolInfo[_pid].lastRewardTimestamp == 0, \"pool already exists\");\n\n        poolInfo[_pid] = PoolInfo({\n            startTimestamp: _startTimestamp,\n            lastRewardTimestamp: _startTimestamp,\n            accTokenPerShare: 0,\n            totalRewards: 0\n        });\n\n        poolIds.push(_pid);\n        emit AddPool(_pid);\n    }\n\n    /// @notice if the new reward info is added, the reward & its end timestamp will be extended by the newly pushed reward info.\n    function addRewardInfo(\n        uint256 _pid,\n        uint256 _endTimestamp,\n        uint256 _rewardPerSec\n    ) external payable onlyOperator(3) {\n        RewardInfo[] storage rewardInfo = poolRewardInfo[_pid];\n        PoolInfo storage pool = poolInfo[_pid];\n        require(rewardInfo.length < rewardInfoLimit, \"add reward info: reward info length exceeds the limit\");\n        require(\n            rewardInfo.length == 0 || rewardInfo[rewardInfo.length - 1].endTimestamp >= block.timestamp,\n            \"add reward info: reward period ended\"\n        );\n        require(\n            rewardInfo.length == 0 || rewardInfo[rewardInfo.length - 1].endTimestamp < _endTimestamp,\n            \"add reward info: bad new endTimestamp\"\n        );\n\n        uint256 startTimestamp = rewardInfo.length == 0\n            ? pool.startTimestamp\n            : rewardInfo[rewardInfo.length - 1].endTimestamp;\n\n        uint256 timeRange = _endTimestamp - startTimestamp;\n        uint256 totalRewards = timeRange * _rewardPerSec;\n        rewardToken.safeTransferFrom(msg.sender, address(this), totalRewards);\n\n        pool.totalRewards += totalRewards;\n\n        rewardInfo.push(\n            RewardInfo({startTimestamp: startTimestamp, endTimestamp: _endTimestamp, rewardPerSec: _rewardPerSec})\n        );\n\n        emit AddRewardInfo(_pid, rewardInfo.length - 1, _endTimestamp, _rewardPerSec);\n    }\n\n    /// @notice Withdraw reward. EMERGENCY ONLY.\n    function emergencyRewardWithdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _beneficiary\n    ) external nonReentrant onlyOperator(3) {\n        PoolInfo storage pool = poolInfo[_pid];\n        uint256 lpSupply = distributor.poolTotalLp(_pid);\n\n        uint256 currentStakingPendingReward = _pendingTokens(_pid, lpSupply, 0);\n\n        require(\n            currentStakingPendingReward + _amount <= pool.totalRewards,\n            \"emergency reward withdraw: not enough reward token\"\n        );\n        pool.totalRewards -= _amount;\n\n        rewardToken.safeTransfer(_beneficiary, _amount);\n    }\n\n    /// @notice Withdraw reward. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _amount, address _beneficiary) external nonReentrant onlyOperator(3) {\n        rewardToken.safeTransfer(_beneficiary, _amount);\n    }\n\n    // Update reward vairables for all pools. Be careful of gas spending!\n    function massUpdatePools() external nonReentrant {\n        _massUpdatePools();\n    }\n\n    /// @notice Function called by FarmDistributor whenever staker claims VELA harvest. Allows staker to also receive a 2nd reward token.\n    /// @param _user Address of user\n    /// @param _amount Number of LP tokens the user has\n    function onVelaReward(uint256 _pid, address _user, uint256 _amount) external override onlyDistributor {\n        PoolInfo memory pool = _updatePool(_pid);\n        UserInfo storage user = userInfo[_pid][_user];\n\n        uint256 pending = 0;\n        uint256 rewardBalance = 0;\n\n        rewardBalance = rewardToken.balanceOf(address(this));\n\n        if (user.amount > 0) {\n            pending = (((user.amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - user.rewardDebt);\n\n            if (pending > 0) {\n                if (pending > rewardBalance) {\n                    rewardToken.safeTransfer(_user, rewardBalance);\n                } else {\n                    rewardToken.safeTransfer(_user, pending);\n                }\n            }\n        }\n\n        user.amount = _amount;\n\n        user.rewardDebt = (user.amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n\n        emit OnReward(_user, pending);\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @param _pid The index of the pool. See `poolInfo`.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(uint256 _pid) external nonReentrant returns (PoolInfo memory pool) {\n        return _updatePool(_pid);\n    }\n\n    // Update reward vairables for all pools. Be careful of gas spending!\n    function _massUpdatePools() internal {\n        uint256 length = poolIds.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            _updatePool(poolIds[pid]);\n        }\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @return pool Returns the pool that was updated.\n    function _updatePool(uint256 pid) internal returns (PoolInfo memory pool) {\n        pool = poolInfo[pid];\n        RewardInfo[] memory rewardInfo = poolRewardInfo[pid];\n        if (block.timestamp <= pool.lastRewardTimestamp) {\n            return pool;\n        }\n\n        uint256 lpSupply = distributor.poolTotalLp(pid);\n\n        if (lpSupply == 0) {\n            // if there is no total supply, return and use the pool's start timestamp as the last reward timestamp\n            // so that ALL reward will be distributed.\n            // however, if the first deposit is out of reward period, last reward timestamp will be its timestamp\n            // in order to keep the multiplier = 0\n            if (block.timestamp > _endTimestampOf(pid, block.timestamp)) {\n                pool.lastRewardTimestamp = block.timestamp;\n                emit UpdatePool(pid, pool.lastRewardTimestamp, lpSupply, pool.accTokenPerShare);\n            }\n\n            return pool;\n        }\n\n        /// @dev for each reward info\n        for (uint256 i = 0; i < rewardInfo.length; ++i) {\n            // @dev get multiplier based on current timestamp and rewardInfo's end timestamp\n            // multiplier will be a range of either (current timestamp - pool.timestamp)\n            // or (reward info's endtimestamp - pool.timestamp) or 0\n            uint256 timeElapsed = getTimeElapsed(pool.lastRewardTimestamp, block.timestamp, rewardInfo[i].endTimestamp);\n            if (timeElapsed == 0) continue;\n\n            // @dev if currentTimestamp exceed end timestamp, use end timestamp as the last reward timestamp\n            // so that for the next iteration, previous endTimestamp will be used as the last reward timestamp\n            if (block.timestamp > rewardInfo[i].endTimestamp) {\n                pool.lastRewardTimestamp = rewardInfo[i].endTimestamp;\n            } else {\n                pool.lastRewardTimestamp = block.timestamp;\n            }\n\n            uint256 tokenReward = (timeElapsed * rewardInfo[i].rewardPerSec);\n\n            pool.accTokenPerShare += ((tokenReward * ACC_TOKEN_PRECISION) / lpSupply);\n        }\n\n        poolInfo[pid] = pool;\n\n        emit UpdatePool(pid, pool.lastRewardTimestamp, lpSupply, pool.accTokenPerShare);\n\n        return pool;\n    }\n\n    /// @notice this will return end timestamp based on the current block timestamp.\n    function currentEndTimestamp(uint256 _pid) external view returns (uint256) {\n        return _endTimestampOf(_pid, block.timestamp);\n    }\n\n    /// @notice View function to see pending Reward on frontend.\n    function pendingTokens(uint256 _pid, address _user) external view override returns (uint256) {\n        return _pendingTokens(_pid, userInfo[_pid][_user].amount, userInfo[_pid][_user].rewardDebt);\n    }\n\n    /// @notice View function to see pool rewards per sec\n    function poolRewardsPerSec(uint256 _pid) external view override returns (uint256) {\n        return _rewardPerSecOf(_pid, block.timestamp);\n    }\n\n    /// @notice Return reward multiplier over the given _from to _to timestamp.\n    function getTimeElapsed(uint256 _from, uint256 _to, uint256 _endTimestamp) public pure returns (uint256) {\n        if ((_from >= _endTimestamp) || (_from > _to)) {\n            return 0;\n        }\n        if (_to <= _endTimestamp) {\n            return _to - _from;\n        }\n        return _endTimestamp - _from;\n    }\n\n    function _endTimestampOf(uint256 _pid, uint256 _timestamp) internal view returns (uint256) {\n        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];\n        uint256 len = rewardInfo.length;\n        if (len == 0) {\n            return 0;\n        }\n        for (uint256 i = 0; i < len; ++i) {\n            if (_timestamp <= rewardInfo[i].endTimestamp) return rewardInfo[i].endTimestamp;\n        }\n\n        /// @dev when couldn't find any reward info, it means that _timestamp exceed endTimestamp\n        /// so return the latest reward info.\n        return rewardInfo[len - 1].endTimestamp;\n    }\n\n    function _pendingTokens(\n        uint256 _pid,\n        uint256 _amount,\n        uint256 _rewardDebt\n    ) internal view returns (uint256 pending) {\n        PoolInfo memory pool = poolInfo[_pid];\n        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];\n\n        uint256 accTokenPerShare = pool.accTokenPerShare;\n        uint256 lpSupply = distributor.poolTotalLp(_pid);\n\n        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {\n            uint256 cursor = pool.lastRewardTimestamp;\n\n            for (uint256 i = 0; i < rewardInfo.length; ++i) {\n                uint256 timeElapsed = getTimeElapsed(cursor, block.timestamp, rewardInfo[i].endTimestamp);\n                if (timeElapsed == 0) continue;\n                cursor = rewardInfo[i].endTimestamp;\n\n                uint256 tokenReward = (timeElapsed * rewardInfo[i].rewardPerSec);\n\n                accTokenPerShare += (tokenReward * ACC_TOKEN_PRECISION) / lpSupply;\n            }\n        }\n\n        pending = (((_amount * accTokenPerShare) / ACC_TOKEN_PRECISION) - _rewardDebt);\n    }\n\n    function _rewardPerSecOf(uint256 _pid, uint256 _blockTimestamp) internal view returns (uint256) {\n        RewardInfo[] memory rewardInfo = poolRewardInfo[_pid];\n        PoolInfo storage pool = poolInfo[_pid];\n        uint256 len = rewardInfo.length;\n        if (len == 0) {\n            return 0;\n        }\n        if (pool.startTimestamp > _blockTimestamp) {\n            return 0;\n        }\n        for (uint256 i = 0; i < len; ++i) {\n            if (_blockTimestamp <= rewardInfo[i].endTimestamp) return rewardInfo[i].rewardPerSec;\n        }\n        /// @dev when couldn't find any reward info, it means that timestamp exceed endblock\n        /// so return 0\n        return 0;\n    }\n}"
    },
    "contracts/staking/interfaces/IBoringERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IBoringERC20 {\n    function mint(address to, uint256 amount) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}"
    },
    "contracts/staking/interfaces/IComplexRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./IBoringERC20.sol\";\n\ninterface IComplexRewarder {\n    function onVelaReward(uint256 pid, address user, uint256 newLpAmount) external;\n\n    function pendingTokens(uint256 pid, address user) external view returns (uint256 pending);\n\n    function rewardToken() external view returns (IBoringERC20);\n\n    function poolRewardsPerSec(uint256 pid) external view returns (uint256);\n}"
    },
    "contracts/staking/interfaces/IFarmDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\ninterface IFarmDistributor {\n    function deposit(uint256 _pid, uint256 _amount) external;\n\n    function poolLength() external view returns (uint256);\n\n    function poolTotalLp(uint256 pid) external view returns (uint256);\n}"
    },
    "contracts/staking/interfaces/ITokenFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\n/**\n * @dev Interface of the VeDxp\n */\ninterface ITokenFarm {\n    function claimable(address _account) external view returns (uint256);\n    function cooldownDuration() external view returns (uint256);\n    function getTierVela(address _account) external view returns (uint256);\n    function getStakedVela(address _account) external view returns (uint256, uint256);\n    function getStakedVLP(address _account) external view returns (uint256, uint256);\n    function getTotalVested(address _account) external view returns (uint256);\n    function pendingTokens(bool _isVelaPool, address _user) external view returns (\n        address[] memory,\n        string[] memory,\n        uint256[] memory,\n        uint256[] memory\n    );\n}"
    },
    "contracts/staking/libraries/BoringERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../interfaces/IBoringERC20.sol\";\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IBoringERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IBoringERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IBoringERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(IBoringERC20 token, address to, uint256 amount) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(IBoringERC20 token, address from, address to, uint256 amount) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n"
    },
    "contracts/staking/TokenFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"./interfaces/IComplexRewarder.sol\";\nimport \"./interfaces/ITokenFarm.sol\";\nimport \"./libraries/BoringERC20.sol\";\nimport \"../core/interfaces/IOperators.sol\";\nimport {Constants} from \"../access/Constants.sol\";\nimport \"../tokens/interfaces/IMintable.sol\";\n\ncontract TokenFarm is ITokenFarm, Constants, Initializable, ReentrancyGuardUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using BoringERC20 for IBoringERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 startTimestamp;\n    }\n\n    struct VelaUserInfo {\n        uint256 velaAmount;\n        uint256 esvelaAmount;\n        uint256 startTimestamp;\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        uint256 totalLp; // Total token in Pool\n        IComplexRewarder[] rewarders; // Array of rewarder contract for pools with incentives\n        bool enableCooldown;\n    }\n    // Total locked up rewards\n    uint256 public totalLockedUpRewards;\n    // The precision factor\n    uint256 private ACC_TOKEN_PRECISION;\n    IBoringERC20 public esVELA;\n    IBoringERC20 public VELA;\n    IBoringERC20 public VLP;\n    IOperators public operators;\n    EnumerableSetUpgradeable.AddressSet private cooldownWhiteList;\n    uint256 public cooldownDuration;\n    uint256 public totalLockedVestingAmount;\n    uint256 public vestingDuration;\n    uint256[] public tierLevels;\n    uint256[] public tierPercents;\n    // Info of each pool\n    PoolInfo public velaPoolInfo;\n    PoolInfo public vlpPoolInfo;\n    //PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP tokens.\n    mapping(address => uint256) public claimedAmounts;\n    mapping(address => uint256) public unlockedVestingAmounts;\n    mapping(address => uint256) public lastVestingUpdateTimes;\n    mapping(address => VelaUserInfo) public velaUserInfo;\n    mapping(address => UserInfo) public vlpUserInfo;\n    mapping(address => uint256) public lockedVestingAmounts;\n\n    event FarmDeposit(address indexed user, IBoringERC20 indexed token, uint256 amount);\n    event EmergencyWithdraw(address indexed user, IBoringERC20 indexed token, uint256 amount);\n    event EmissionRateUpdated(address indexed caller, uint256 previousValue, uint256 newValue);\n    event MintVestingToken(address indexed account, uint256 amount);\n    event RewardLockedUp(address indexed user, IBoringERC20 indexed token, uint256 amountLockedUp);\n    event Set(IBoringERC20 indexed token, IComplexRewarder[] indexed rewarders);\n    event UpdateCooldownDuration(uint256 cooldownDuration);\n    event UpdateVestingPeriod(uint256 vestingPeriod);\n    event UpdateRewardTierInfo(uint256[] levels, uint256[] percents);\n    event VestingClaim(address receiver, uint256 amount);\n    event VestingDeposit(address account, uint256 amount);\n    event VestingTransfer(address indexed from, address indexed to, uint256 value);\n    event VestingWithdraw(address account, uint256 claimedAmount, uint256 balance);\n    event FarmWithdraw(address indexed user, IBoringERC20 indexed token, uint256 amount);\n\n    modifier onlyOperator(uint256 level) {\n        require(operators.getOperatorLevel(msg.sender) >= level, \"invalid operator\");\n        _;\n    }\n\n    function initialize(\n        uint256 _vestingDuration,\n        IBoringERC20 _esVELA,\n        IBoringERC20 _VELA,\n        IBoringERC20 _vlp,\n        address _operators\n    ) public initializer {\n        __ReentrancyGuard_init();\n        //StartBlock always many years later from contract const ruct, will be set later in StartFarming function\n        require(AddressUpgradeable.isContract(_operators), \"operators invalid\");\n        operators = IOperators(_operators);\n        VELA = _VELA;\n        esVELA = _esVELA;\n        VLP = _vlp;\n        ACC_TOKEN_PRECISION = 1e12;\n        cooldownDuration = 1 weeks;\n        vestingDuration = _vestingDuration;\n    }\n\n    function addDelegatesToCooldownWhiteList(address[] memory _delegates) external onlyOperator(1) {\n        for (uint256 i = 0; i < _delegates.length; ++i) {\n            EnumerableSetUpgradeable.add(cooldownWhiteList, _delegates[i]);\n        }\n    }\n\n    function removeDelegatesFromCooldownWhiteList(address[] memory _delegates) external onlyOperator(1) {\n        for (uint256 i = 0; i < _delegates.length; ++i) {\n            EnumerableSetUpgradeable.remove(cooldownWhiteList, _delegates[i]);\n        }\n    }\n\n    function checkCooldownWhiteList(address _delegate) public view returns (bool) {\n        return EnumerableSetUpgradeable.contains(cooldownWhiteList, _delegate);\n    }\n\n    // ----- START: Operator Logic -----\n    // Update rewarders and enableCooldown for pools\n    function setVelaPool(IComplexRewarder[] calldata _rewarders, bool _enableCooldown) external onlyOperator(1) {\n        require(_rewarders.length <= 10, \"set: too many rewarders\");\n\n        for (uint256 rewarderId = 0; rewarderId < _rewarders.length; ++rewarderId) {\n            require(AddressUpgradeable.isContract(address(_rewarders[rewarderId])), \"set: rewarder must be contract\");\n        }\n\n        velaPoolInfo.rewarders = _rewarders;\n        velaPoolInfo.enableCooldown = _enableCooldown;\n\n        emit Set(VELA, _rewarders);\n    }\n\n    function setVlpPool(IComplexRewarder[] calldata _rewarders, bool _enableCooldown) external onlyOperator(1) {\n        require(_rewarders.length <= 10, \"set: too many rewarders\");\n\n        for (uint256 rewarderId = 0; rewarderId < _rewarders.length; ++rewarderId) {\n            require(AddressUpgradeable.isContract(address(_rewarders[rewarderId])), \"set: rewarder must be contract\");\n        }\n\n        vlpPoolInfo.rewarders = _rewarders;\n        vlpPoolInfo.enableCooldown = _enableCooldown;\n\n        emit Set(VLP, _rewarders);\n    }\n\n    function updateCooldownDuration(uint256 _newCooldownDuration) external onlyOperator(1) {\n        require(_newCooldownDuration <= MAX_TOKENFARM_COOLDOWN_DURATION, \"cooldown duration exceeds max\");\n        cooldownDuration = _newCooldownDuration;\n        emit UpdateCooldownDuration(_newCooldownDuration);\n    }\n\n    function updateRewardTierInfo(uint256[] memory _levels, uint256[] memory _percents) external onlyOperator(1) {\n        uint256 totalLength = tierLevels.length;\n        require(_levels.length == _percents.length, \"the length should the same\");\n        require(_validateLevels(_levels), \"levels not sorted\");\n        require(_validatePercents(_percents), \"percents exceed 100%\");\n        for (uint256 i = 0; i < totalLength; i++) {\n            tierLevels.pop();\n            tierPercents.pop();\n        }\n        for (uint256 j = 0; j < _levels.length; j++) {\n            tierLevels.push(_levels[j]);\n            tierPercents.push(_percents[j]);\n        }\n        emit UpdateRewardTierInfo(_levels, _percents);\n    }\n\n    function updateVestingDuration(uint256 _vestingDuration) external onlyOperator(1) {\n        require(_vestingDuration <= MAX_VESTING_DURATION, \"vesting duration exceeds max\");\n        vestingDuration = _vestingDuration;\n        emit UpdateVestingPeriod(_vestingDuration);\n    }\n\n    // ----- END: Operator Logic -----\n\n    // ----- START: Vesting esVELA -> VELA -----\n\n    function claim() external nonReentrant {\n        address account = msg.sender;\n        address _receiver = account;\n        _claim(account, _receiver);\n    }\n\n    function claimable(address _account) public view returns (uint256) {\n        return getUnlockedVestingAmount(_account) - claimedAmounts[_account];\n    }\n\n    function getUnlockedVestingAmount(address _account) public view returns (uint256) {\n        uint256 lockedAmount = lockedVestingAmounts[_account];\n        if (lockedAmount == 0) {\n            return 0;\n        }\n        uint256 timeDiff = block.timestamp - lastVestingUpdateTimes[_account];\n        // `timeDiff == block.timestamp` means `lastVestingTimes[_account]` has not been initialized\n        if (timeDiff == 0 || timeDiff == block.timestamp) {\n            return 0;\n        }\n\n        uint256 claimableAmount = (lockedAmount * timeDiff) / vestingDuration;\n\n        if (claimableAmount < lockedAmount) {\n            return claimableAmount;\n        }\n\n        return lockedAmount;\n    }\n\n    function withdrawVesting() external nonReentrant {\n        address account = msg.sender;\n        address _receiver = account;\n        uint256 totalClaimed = _claim(account, _receiver);\n\n        uint256 totalLocked = lockedVestingAmounts[account];\n        require(totalLocked > 0, \"Vester: vested amount is zero\");\n\n        esVELA.safeTransfer(_receiver, totalLocked - totalClaimed);\n        _decreaseLockedVestingAmount(account, totalLocked);\n\n        delete claimedAmounts[account];\n        delete lastVestingUpdateTimes[account];\n\n        emit VestingWithdraw(account, totalClaimed, totalLocked);\n    }\n\n    function _claim(address _account, address _receiver) internal returns (uint256) {\n        uint256 amount = claimable(_account);\n        claimedAmounts[_account] = claimedAmounts[_account] + amount;\n        IMintable(address(esVELA)).burn(address(this), amount);\n        VELA.safeTransfer(_receiver, amount);\n        emit VestingClaim(_account, amount);\n        return amount;\n    }\n\n    function depositVesting(uint256 _amount) external nonReentrant {\n        _depositVesting(msg.sender, _amount);\n    }\n\n    function depositVelaForVesting(uint256 _amount) external nonReentrant {\n        require(_amount > 0, \"zero amount\");\n        VELA.safeTransferFrom(msg.sender, address(this), _amount); //transfer VELA in\n        esVELA.mint(msg.sender, _amount);\n        emit MintVestingToken(msg.sender, _amount);\n    }\n\n    function _decreaseLockedVestingAmount(address _account, uint256 _amount) internal {\n        lockedVestingAmounts[_account] -= _amount;\n        totalLockedVestingAmount -= _amount;\n\n        emit VestingTransfer(_account, address(0), _amount);\n    }\n\n    function _depositVesting(address _account, uint256 _amount) internal {\n        require(_amount > 0, \"Vester: invalid _amount\");\n\n        _claim(_account, _account);\n        uint256 claimedAmount = claimedAmounts[_account];\n        delete claimedAmounts[_account];\n\n        lockedVestingAmounts[_account] = lockedVestingAmounts[_account] - claimedAmount + _amount;\n        totalLockedVestingAmount = totalLockedVestingAmount - claimedAmount + _amount;\n\n        lastVestingUpdateTimes[_account] = block.timestamp;\n\n        esVELA.safeTransferFrom(_account, address(this), _amount);\n\n        emit VestingDeposit(_account, _amount);\n    }\n\n    function getStakedVela(address _account) external view returns (uint256, uint256) {\n        VelaUserInfo memory user = velaUserInfo[_account];\n        return (user.velaAmount, user.esvelaAmount);\n    }\n\n    function getStakedVLP(address _account) external view returns (uint256, uint256) {\n        UserInfo memory user = vlpUserInfo[_account];\n        return (user.amount, user.startTimestamp);\n    }\n\n    function getTotalVested(address _account) external view returns (uint256) {\n        return lockedVestingAmounts[_account];\n    }\n\n    // ----- END: Vesting esVELA -> VELA -----\n\n    // ----- START: VELA Pool, pid=0, token VELA -----\n    function depositVela(uint256 _amount) external nonReentrant {\n        _depositVela(_amount);\n    }\n\n    function _depositVela(uint256 _amount) internal {\n        uint256 _pid = 0;\n        PoolInfo storage pool = velaPoolInfo;\n        VelaUserInfo storage user = velaUserInfo[msg.sender];\n\n        if (_amount > 0) {\n            VELA.safeTransferFrom(msg.sender, address(this), _amount);\n            user.velaAmount += _amount;\n            user.startTimestamp = block.timestamp;\n        }\n\n        for (uint256 rewarderId = 0; rewarderId < pool.rewarders.length; ++rewarderId) {\n            pool.rewarders[rewarderId].onVelaReward(_pid, msg.sender, user.velaAmount + user.esvelaAmount);\n        }\n\n        if (_amount > 0) {\n            pool.totalLp += _amount;\n        }\n        emit FarmDeposit(msg.sender, VELA, _amount);\n    }\n\n    //withdraw tokens\n    function withdrawVela(uint256 _amount) external nonReentrant {\n        uint256 _pid = 0;\n        PoolInfo storage pool = velaPoolInfo;\n        VelaUserInfo storage user = velaUserInfo[msg.sender];\n\n        //this will make sure that user can only withdraw from his pool\n        require(user.velaAmount >= _amount, \"withdraw: user amount not enough\");\n\n        if (_amount > 0) {\n            require(\n                !pool.enableCooldown || user.startTimestamp + cooldownDuration < block.timestamp,\n                \"didn't pass cooldownDuration\"\n            );\n            user.velaAmount -= _amount;\n            VELA.safeTransfer(msg.sender, _amount);\n        }\n\n        for (uint256 rewarderId = 0; rewarderId < pool.rewarders.length; ++rewarderId) {\n            pool.rewarders[rewarderId].onVelaReward(_pid, msg.sender, user.velaAmount + user.esvelaAmount);\n        }\n\n        if (_amount > 0) {\n            pool.totalLp -= _amount;\n        }\n\n        emit FarmWithdraw(msg.sender, VELA, _amount);\n    }\n\n    // ----- END: VELA Pool, pid=0, token VELA -----\n\n    // ----- START: VELA Pool, pid=0, token esVELA -----\n    function depositEsvela(uint256 _amount) external nonReentrant {\n        _depositEsvela(_amount);\n    }\n\n    function _depositEsvela(uint256 _amount) internal {\n        uint256 _pid = 0;\n        PoolInfo storage pool = velaPoolInfo;\n        VelaUserInfo storage user = velaUserInfo[msg.sender];\n\n        if (_amount > 0) {\n            esVELA.safeTransferFrom(msg.sender, address(this), _amount);\n            user.esvelaAmount += _amount;\n            user.startTimestamp = block.timestamp;\n        }\n\n        for (uint256 rewarderId = 0; rewarderId < pool.rewarders.length; ++rewarderId) {\n            pool.rewarders[rewarderId].onVelaReward(_pid, msg.sender, user.velaAmount + user.esvelaAmount);\n        }\n\n        if (_amount > 0) {\n            pool.totalLp += _amount;\n        }\n        emit FarmDeposit(msg.sender, esVELA, _amount);\n    }\n\n    //withdraw tokens\n    function withdrawEsvela(uint256 _amount) external nonReentrant {\n        uint256 _pid = 0;\n        PoolInfo storage pool = velaPoolInfo;\n        VelaUserInfo storage user = velaUserInfo[msg.sender];\n\n        //this will make sure that user can only withdraw from his pool\n        require(user.esvelaAmount >= _amount, \"withdraw: user amount not enough\");\n\n        if (_amount > 0) {\n            require(\n                !pool.enableCooldown || user.startTimestamp + cooldownDuration < block.timestamp,\n                \"didn't pass cooldownDuration\"\n            );\n            user.esvelaAmount -= _amount;\n            esVELA.safeTransfer(msg.sender, _amount);\n        }\n\n        for (uint256 rewarderId = 0; rewarderId < pool.rewarders.length; ++rewarderId) {\n            pool.rewarders[rewarderId].onVelaReward(_pid, msg.sender, user.velaAmount + user.esvelaAmount);\n        }\n\n        if (_amount > 0) {\n            pool.totalLp -= _amount;\n        }\n\n        emit FarmWithdraw(msg.sender, esVELA, _amount);\n    }\n\n    // ----- END: VELA Pool, pid=0, token esVELA -----\n\n    // ----- START: both VELA and esVELA, pid=0\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    // token VELA and esVELA\n    function emergencyWithdrawVela() external nonReentrant {\n        PoolInfo storage pool = velaPoolInfo;\n        VelaUserInfo storage user = velaUserInfo[msg.sender];\n        uint256 _velaAmount = user.velaAmount;\n        uint256 _esVelaAmount = user.esvelaAmount;\n        if (_esVelaAmount > 0 || _velaAmount > 0) {\n            require(\n                !pool.enableCooldown || user.startTimestamp + cooldownDuration <= block.timestamp,\n                \"didn't pass cooldownDuration\"\n            );\n        }\n        if (_velaAmount > 0) {\n            VELA.safeTransfer(msg.sender, _velaAmount);\n            pool.totalLp -= _velaAmount;\n            user.velaAmount = 0;\n            emit EmergencyWithdraw(msg.sender, VELA, _velaAmount);\n        }\n        if (_esVelaAmount > 0) {\n            esVELA.safeTransfer(msg.sender, _esVelaAmount);\n            pool.totalLp -= _esVelaAmount;\n            user.esvelaAmount = 0;\n            emit EmergencyWithdraw(msg.sender, esVELA, _esVelaAmount);\n        }\n    }\n\n    // ----- END: both VELA and esVELA, pid=0\n\n    // ----- START: VLP Pool, pid=1, token VLP -----\n\n    function depositVlp(uint256 _amount) external {\n        _depositVlp(_amount);\n    }\n\n    function _depositVlp(uint256 _amount) internal {\n        uint256 _pid = 1;\n        PoolInfo storage pool = vlpPoolInfo;\n        UserInfo storage user = vlpUserInfo[msg.sender];\n        if (_amount > 0) {\n            VLP.safeTransferFrom(msg.sender, address(this), _amount);\n            user.amount += _amount;\n            user.startTimestamp = block.timestamp;\n        }\n\n        for (uint256 rewarderId = 0; rewarderId < pool.rewarders.length; ++rewarderId) {\n            pool.rewarders[rewarderId].onVelaReward(_pid, msg.sender, user.amount);\n        }\n\n        if (_amount > 0) {\n            pool.totalLp += _amount;\n        }\n        emit FarmDeposit(msg.sender, VLP, _amount);\n    }\n\n    function emergencyWithdrawVlp() external {\n        PoolInfo storage pool = vlpPoolInfo;\n        UserInfo storage user = vlpUserInfo[msg.sender];\n        uint256 _amount = user.amount;\n        if (_amount > 0) {\n            if (!checkCooldownWhiteList(msg.sender)) {\n                require(\n                    !pool.enableCooldown || user.startTimestamp + cooldownDuration <= block.timestamp,\n                    \"didn't pass cooldownDuration\"\n                );\n            }\n            VLP.safeTransfer(msg.sender, _amount);\n            pool.totalLp -= _amount;\n        }\n        user.amount = 0;\n        emit EmergencyWithdraw(msg.sender, VLP, _amount);\n    }\n\n    //withdraw tokens\n    function withdrawVlp(uint256 _amount) external nonReentrant {\n        uint256 _pid = 1;\n        PoolInfo storage pool = vlpPoolInfo;\n        UserInfo storage user = vlpUserInfo[msg.sender];\n\n        //this will make sure that user can only withdraw from his pool\n        require(user.amount >= _amount, \"withdraw: user amount not enough\");\n\n        if (_amount > 0) {\n            if (!checkCooldownWhiteList(msg.sender)) {\n                require(\n                    !pool.enableCooldown || user.startTimestamp + cooldownDuration < block.timestamp,\n                    \"didn't pass cooldownDuration\"\n                );\n            }\n            user.amount -= _amount;\n            VLP.safeTransfer(msg.sender, _amount);\n        }\n\n        for (uint256 rewarderId = 0; rewarderId < pool.rewarders.length; ++rewarderId) {\n            pool.rewarders[rewarderId].onVelaReward(_pid, msg.sender, user.amount);\n        }\n\n        if (_amount > 0) {\n            pool.totalLp -= _amount;\n        }\n\n        emit FarmWithdraw(msg.sender, VLP, _amount);\n    }\n\n    // ----- END: VLP Pool, pid=1, token VLP -----\n\n    // View function to see rewarders for a pool\n    function poolRewarders(bool _isVelaPool) external view returns (address[] memory rewarders) {\n        PoolInfo storage pool;\n        if (_isVelaPool) {\n            pool = velaPoolInfo;\n        } else {\n            pool = vlpPoolInfo;\n        }\n        rewarders = new address[](pool.rewarders.length);\n        for (uint256 rewarderId = 0; rewarderId < pool.rewarders.length; ++rewarderId) {\n            rewarders[rewarderId] = address(pool.rewarders[rewarderId]);\n        }\n    }\n\n    /// @notice View function to see pool rewards per sec\n    function poolRewardsPerSec(\n        bool _isVelaPool\n    )\n        external\n        view\n        returns (\n            address[] memory addresses,\n            string[] memory symbols,\n            uint256[] memory decimals,\n            uint256[] memory rewardsPerSec\n        )\n    {\n        uint256 _pid;\n        PoolInfo storage pool;\n        if (_isVelaPool) {\n            _pid = 0;\n            pool = velaPoolInfo;\n        } else {\n            _pid = 1;\n            pool = vlpPoolInfo;\n        }\n\n        addresses = new address[](pool.rewarders.length);\n        symbols = new string[](pool.rewarders.length);\n        decimals = new uint256[](pool.rewarders.length);\n        rewardsPerSec = new uint256[](pool.rewarders.length);\n\n        for (uint256 rewarderId = 0; rewarderId < pool.rewarders.length; ++rewarderId) {\n            addresses[rewarderId] = address(pool.rewarders[rewarderId].rewardToken());\n\n            symbols[rewarderId] = IBoringERC20(pool.rewarders[rewarderId].rewardToken()).safeSymbol();\n\n            decimals[rewarderId] = IBoringERC20(pool.rewarders[rewarderId].rewardToken()).safeDecimals();\n\n            rewardsPerSec[rewarderId] = pool.rewarders[rewarderId].poolRewardsPerSec(_pid);\n        }\n    }\n\n    function poolTotalLp(uint256 _pid) external view returns (uint256) {\n        PoolInfo storage pool;\n        if (_pid == 0) {\n            pool = velaPoolInfo;\n        } else {\n            pool = vlpPoolInfo;\n        }\n        return pool.totalLp;\n    }\n\n    // View function to see pending rewards on frontend.\n    function pendingTokens(\n        bool _isVelaPool,\n        address _user\n    )\n        external\n        view\n        returns (\n            address[] memory addresses,\n            string[] memory symbols,\n            uint256[] memory decimals,\n            uint256[] memory amounts\n        )\n    {\n        uint256 _pid;\n        PoolInfo storage pool;\n        if (_isVelaPool) {\n            _pid = 0;\n            pool = velaPoolInfo;\n        } else {\n            _pid = 1;\n            pool = vlpPoolInfo;\n        }\n        addresses = new address[](pool.rewarders.length);\n        symbols = new string[](pool.rewarders.length);\n        amounts = new uint256[](pool.rewarders.length);\n        decimals = new uint256[](pool.rewarders.length);\n\n        for (uint256 rewarderId = 0; rewarderId < pool.rewarders.length; ++rewarderId) {\n            addresses[rewarderId] = address(pool.rewarders[rewarderId].rewardToken());\n\n            symbols[rewarderId] = IBoringERC20(pool.rewarders[rewarderId].rewardToken()).safeSymbol();\n\n            decimals[rewarderId] = IBoringERC20(pool.rewarders[rewarderId].rewardToken()).safeDecimals();\n            amounts[rewarderId] = pool.rewarders[rewarderId].pendingTokens(_pid, _user);\n        }\n    }\n\n    // Function to harvest many pools in a single transaction\n    function harvestMany(bool _vela, bool _esvela, bool _vlp, bool _vesting) public nonReentrant {\n        if (_vela) {\n            _depositVela(0);\n        }\n        if (_esvela) {\n            _depositEsvela(0);\n        }\n        if (_vlp) {\n            _depositVlp(0);\n        }\n        if (_vesting) {\n            _claim(msg.sender, msg.sender);\n        }\n    }\n\n    function harvestManyPacked() external {\n        //0xddc75927\n        uint x;\n        assembly {\n            x := calldataload(4)\n        }\n        // param is only 0.5 byte (4bits)\n        x = x >> 252;\n        harvestMany(x & (2 ** 3) > 0, x & (2 ** 2) > 0, x & 2 > 0, x & 1 > 0);\n    }\n\n    function getTierVela(address _account) external view override returns (uint256) {\n        VelaUserInfo storage user = velaUserInfo[_account];\n        uint256 amount = user.velaAmount + user.esvelaAmount;\n        if (tierLevels.length == 0 || amount < tierLevels[0]) {\n            return BASIS_POINTS_DIVISOR;\n        }\n        unchecked {\n            for (uint16 i = 1; i != tierLevels.length; ++i) {\n                if (amount < tierLevels[i]) {\n                    return tierPercents[i - 1];\n                }\n            }\n            return tierPercents[tierLevels.length - 1];\n        }\n    }\n\n    function _validateLevels(uint256[] memory _levels) internal pure returns (bool) {\n        unchecked {\n            for (uint16 i = 1; i != _levels.length; ++i) {\n                if (_levels[i - 1] >= _levels[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function _validatePercents(uint256[] memory _percents) internal pure returns (bool) {\n        unchecked {\n            for (uint16 i = 0; i != _percents.length; ++i) {\n                if (_percents[i] > BASIS_POINTS_DIVISOR) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}"
    },
    "contracts/tokens/BaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract BaseToken is IERC20, Ownable {\n    using SafeERC20 for IERC20;\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowances;\n\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) {\n        name = _name;\n        symbol = _symbol;\n        _mint(msg.sender, _initialSupply);\n    }\n\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function setInfo(string memory _name, string memory _symbol) external onlyOwner {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function transfer(address _recipient, uint256 _amount) public virtual override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) public virtual override returns (bool) {\n        require(allowances[_sender][msg.sender] >= _amount, \"BaseToken: transfer amount exceeds allowance\");\n        uint256 nextAllowance = allowances[_sender][msg.sender] - _amount;\n        _approve(_sender, msg.sender, nextAllowance);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_spender != address(0), \"BaseToken: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"BaseToken: burn from the zero address\");\n\n        require(balances[_account] >= _amount, \"BaseToken: burn amount exceeds balance\");\n        balances[_account] -= _amount;\n        totalSupply -= _amount;\n\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"BaseToken: mint to the zero address\");\n\n        totalSupply += _amount;\n        balances[_account] += _amount;\n\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_recipient != address(0), \"BaseToken: transfer to the zero address\");\n\n        require(balances[_sender] >= _amount, \"BaseToken: transfer amount exceeds balance\");\n        balances[_sender] -= _amount;\n        balances[_recipient] += _amount;\n\n        emit Transfer(_sender, _recipient, _amount);\n    }\n}"
    },
    "contracts/tokens/eVela.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../tokens/MintableBaseToken.sol\";\n\ncontract eVELA is MintableBaseToken {\n    constructor() MintableBaseToken(\"Escrowed VELA\", \"esVELA\", 0) {}\n\n    function id() external pure returns (string memory _name) {\n        return \"esVELA\";\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IMintable {\n    function burn(address _account, uint256 _amount) external;\n\n    function mint(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/tokens/interfaces/IVUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IVUSD {\n    function burn(address _account, uint256 _amount) external;\n\n    function mint(address _account, uint256 _amount) external;\n\n    function balanceOf(address _account) external view returns (uint256);\n}"
    },
    "contracts/tokens/MintableBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./BaseToken.sol\";\nimport \"./interfaces/IMintable.sol\";\n\ncontract MintableBaseToken is BaseToken, IMintable {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _initialSupply\n    ) BaseToken(_name, _symbol, _initialSupply) {}\n\n    function burn(address _account, uint256 _amount) external override onlyOwner {\n        _burn(_account, _amount);\n    }\n\n    function mint(address _account, uint256 _amount) external override onlyOwner {\n        _mint(_account, _amount);\n    }\n}"
    },
    "contracts/tokens/VELA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract Vela is ERC20, ERC20Permit, Pausable, AccessControl {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant RESCUER_ROLE = keccak256(\"RESCUER_ROLE\");\n\n    address private _trustedForwarder;\n    // Control support for EIP-2771 Meta Transactions\n    bool public metaTxnsEnabled;\n\n    uint256 private _initialSupply; // 0 tokens is the initial supply\n    uint256 private _maxSupply = 100000000 * 10 ** decimals(); // 100M tokens is maximum supply\n\n    event MetaTxnsDisabled(address indexed caller);\n    event MetaTxnsEnabled(address indexed caller);\n    event TokensRescued(address indexed sender, address indexed token, uint256 value);\n\n    constructor(address trustedForwarder) ERC20(\"Vela\", \"VELA\") ERC20Permit(\"Vela\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(RESCUER_ROLE, _msgSender());\n        _trustedForwarder = trustedForwarder;\n        _mint(_msgSender(), _initialSupply);\n    }\n\n    // Disable support for meta transactions\n    function disableMetaTxns() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(metaTxnsEnabled, \"Meta transactions are already disabled\");\n\n        metaTxnsEnabled = false;\n        emit MetaTxnsDisabled(_msgSender());\n    }\n\n    // Enable support for meta transactions\n    function enableMetaTxns() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(!metaTxnsEnabled, \"Meta transactions are already enabled\");\n\n        metaTxnsEnabled = true;\n        emit MetaTxnsEnabled(_msgSender());\n    }\n\n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n        require(totalSupply() + amount <= _maxSupply, \"ERC20: cannot mint more tokens, cap exceeded\");\n        _mint(to, amount);\n    }\n\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    function rescueTokens(IERC20 token, uint256 value) external onlyRole(RESCUER_ROLE) {\n        token.transfer(_msgSender(), value);\n        emit TokensRescued(_msgSender(), address(token), value);\n    }\n\n    function unpause() external onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @dev Returns the maximum amount of tokens that can be minted.\n     */\n    function maxSupply() external view returns (uint256) {\n        return _maxSupply;\n    }\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override whenNotPaused {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function _msgData() internal view override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    function _msgSender() internal view override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n}\n"
    },
    "contracts/tokens/VLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./MintableBaseToken.sol\";\nimport \"../core/interfaces/IVault.sol\";\nimport \"../core/interfaces/ISettingsManager.sol\";\n\ncontract VLP is MintableBaseToken {\n    IVault public vault;\n    ISettingsManager public settingsManager;\n\n    constructor() MintableBaseToken(\"Vela LP\", \"VLP\", 0) {}\n\n    function initialize(address _vault, address _settingsManager) external onlyOwner {\n        vault = IVault(_vault);\n        settingsManager = ISettingsManager(_settingsManager);\n    }\n\n    function id() external pure returns (string memory _name) {\n        return \"VLP\";\n    }\n\n    function transfer(address _recipient, uint256 _amount) public override returns (bool) {\n        require(\n            vault.lastStakedAt(msg.sender) + settingsManager.cooldownDuration() <= block.timestamp,\n            \"cooldown duration not yet passed\"\n        );\n        return super.transfer(_recipient, _amount);\n    }\n\n    function transferFrom(address _sender, address _recipient, uint256 _amount) public override returns (bool) {\n        if (!settingsManager.isWhitelistedFromTransferCooldown(_recipient)) {\n            require(\n                vault.lastStakedAt(_sender) + settingsManager.cooldownDuration() <= block.timestamp,\n                \"cooldown duration not yet passed\"\n            );\n        }\n\n        return super.transferFrom(_sender, _recipient, _amount);\n    }\n}"
    },
    "contracts/tokens/VUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IVUSD.sol\";\n\ncontract VUSD is IVUSD, Ownable {\n    uint8 public constant decimals = 30;\n\n    string public name;\n    string public symbol;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balances;\n    event Burn(address indexed account, uint256 value);\n    event Mint(address indexed beneficiary, uint256 value);\n\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) {\n        name = _name;\n        symbol = _symbol;\n        _mint(msg.sender, _initialSupply);\n    }\n\n    function burn(address _account, uint256 _amount) external override onlyOwner {\n        _burn(_account, _amount);\n    }\n\n    function mint(address _account, uint256 _amount) external override onlyOwner {\n        _mint(_account, _amount);\n    }\n\n    function setInfo(string memory _name, string memory _symbol) external onlyOwner {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function balanceOf(address _account) external view override returns (uint256) {\n        return balances[_account];\n    }\n\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"VUSD: burn from the zero address\");\n\n        require(balances[_account] >= _amount, \"VUSD: burn amount exceeds balance\");\n        balances[_account] -= _amount;\n        totalSupply -= _amount;\n        emit Burn(_account, _amount);\n    }\n\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"VUSD: mint to the zero address\");\n        totalSupply += _amount;\n        balances[_account] += _amount;\n        emit Mint(_account, _amount);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}